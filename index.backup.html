<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Magic Affinity</title>
        <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚öîÔ∏è</text></svg>">
        <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
        <style>
            body {
                margin: 0;
                padding: 0;
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                background: #1a1a2e;
                font-family: "Courier New", monospace;
            }
            #game-container {
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            }
        </style>
    </head>
    <body>
        <div id="game-container"></div>

        <script>
            // Global Game State
            const gameState = {
                selectedCharacter: null,
                currentLevel: 1,
                totalXP: 0,
                enemiesKilled: 0,
                survivalTime: 0,
                highScore: 0,
                currentSeason: null, // spring, summer, fall, winter
            };

            // Element System - 10 Magical Elements
            const ELEMENTS = {
                flame: {
                    name: "Flame",
                    icon: "üî•",
                    color: 0xff4500, // Red-Orange
                    description: "Burn enemies over time",
                    effect: "burn"
                },
                water: {
                    name: "Water",
                    icon: "üíß",
                    color: 0x4169e1, // Blue
                    description: "Freeze enemies in place",
                    effect: "freeze"
                },
                electric: {
                    name: "Electric",
                    icon: "‚ö°",
                    color: 0xffff00, // Yellow
                    description: "Paralyze and chain damage",
                    effect: "paralyze"
                },
                nature: {
                    name: "Nature",
                    icon: "üåø",
                    color: 0x32cd32, // Green
                    description: "Poison that doubles damage",
                    effect: "poison"
                },
                wind: {
                    name: "Wind",
                    icon: "üí®",
                    color: 0x87ceeb, // Light Cyan
                    description: "Knockback and sleep",
                    effect: "sleep"
                },
                terra: {
                    name: "Terra",
                    icon: "ü™®",
                    color: 0x8b4513, // Brown
                    description: "Strong knockback",
                    effect: "knockback"
                },
                gravity: {
                    name: "Gravity",
                    icon: "üåå",
                    color: 0x9370db, // Purple
                    description: "Slow and confuse enemies",
                    effect: "slow"
                },
                celestial: {
                    name: "Celestial",
                    icon: "‚ú®",
                    color: 0xffd700, // Gold with shimmer
                    description: "Charm enemies",
                    effect: "charm"
                },
                radiant: {
                    name: "Radiant",
                    icon: "‚òÄÔ∏è",
                    color: 0xfffacd, // Bright White-Gold
                    description: "Blind and buff allies",
                    effect: "blind"
                },
                shadow: {
                    name: "Shadow",
                    icon: "üåë",
                    color: 0x4b0082, // Dark Purple/Indigo
                    description: "Fear and weaken enemies",
                    effect: "fear"
                }
            };

            // Sound Effects System using Web Audio API
            class SoundFX {
                constructor() {
                    this.audioContext = new (window.AudioContext ||
                        window.webkitAudioContext)();
                    this.masterVolume = 0.3; // Global volume control
                }

                // Play a sound effect
                play(type) {
                    switch (type) {
                        case "shoot":
                            this.playShoot();
                            break;
                        case "hit":
                            this.playHit();
                            break;
                        case "enemyDeath":
                            this.playEnemyDeath();
                            break;
                        case "playerHit":
                            this.playPlayerHit();
                            break;
                        case "xpCollect":
                            this.playXPCollect();
                            break;
                        case "levelUp":
                            this.playLevelUp();
                            break;
                        case "select":
                            this.playSelect();
                            break;
                        case "hover":
                            this.playHover();
                            break;
                    }
                }

                playShoot() {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);

                    osc.frequency.setValueAtTime(
                        400,
                        this.audioContext.currentTime,
                    );
                    osc.frequency.exponentialRampToValueAtTime(
                        200,
                        this.audioContext.currentTime + 0.1,
                    );

                    gain.gain.setValueAtTime(
                        this.masterVolume * 0.3,
                        this.audioContext.currentTime,
                    );
                    gain.gain.exponentialRampToValueAtTime(
                        0.01,
                        this.audioContext.currentTime + 0.1,
                    );

                    osc.start(this.audioContext.currentTime);
                    osc.stop(this.audioContext.currentTime + 0.1);
                }

                playHit() {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);

                    osc.type = "square";
                    osc.frequency.setValueAtTime(
                        200,
                        this.audioContext.currentTime,
                    );
                    osc.frequency.exponentialRampToValueAtTime(
                        50,
                        this.audioContext.currentTime + 0.05,
                    );

                    gain.gain.setValueAtTime(
                        this.masterVolume * 0.4,
                        this.audioContext.currentTime,
                    );
                    gain.gain.exponentialRampToValueAtTime(
                        0.01,
                        this.audioContext.currentTime + 0.05,
                    );

                    osc.start(this.audioContext.currentTime);
                    osc.stop(this.audioContext.currentTime + 0.05);
                }

                playEnemyDeath() {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);

                    osc.type = "sawtooth";
                    osc.frequency.setValueAtTime(
                        300,
                        this.audioContext.currentTime,
                    );
                    osc.frequency.exponentialRampToValueAtTime(
                        50,
                        this.audioContext.currentTime + 0.2,
                    );

                    gain.gain.setValueAtTime(
                        this.masterVolume * 0.5,
                        this.audioContext.currentTime,
                    );
                    gain.gain.exponentialRampToValueAtTime(
                        0.01,
                        this.audioContext.currentTime + 0.2,
                    );

                    osc.start(this.audioContext.currentTime);
                    osc.stop(this.audioContext.currentTime + 0.2);
                }

                playPlayerHit() {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);

                    osc.type = "sawtooth";
                    osc.frequency.setValueAtTime(
                        100,
                        this.audioContext.currentTime,
                    );

                    gain.gain.setValueAtTime(
                        this.masterVolume * 0.6,
                        this.audioContext.currentTime,
                    );
                    gain.gain.exponentialRampToValueAtTime(
                        0.01,
                        this.audioContext.currentTime + 0.15,
                    );

                    osc.start(this.audioContext.currentTime);
                    osc.stop(this.audioContext.currentTime + 0.15);
                }

                playXPCollect() {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);

                    osc.type = "sine";
                    osc.frequency.setValueAtTime(
                        800,
                        this.audioContext.currentTime,
                    );
                    osc.frequency.exponentialRampToValueAtTime(
                        1200,
                        this.audioContext.currentTime + 0.1,
                    );

                    gain.gain.setValueAtTime(
                        this.masterVolume * 0.3,
                        this.audioContext.currentTime,
                    );
                    gain.gain.exponentialRampToValueAtTime(
                        0.01,
                        this.audioContext.currentTime + 0.1,
                    );

                    osc.start(this.audioContext.currentTime);
                    osc.stop(this.audioContext.currentTime + 0.1);
                }

                playLevelUp() {
                    // Play a quick ascending arpeggio
                    const notes = [523.25, 659.25, 783.99, 1046.5]; // C, E, G, C
                    notes.forEach((freq, i) => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();

                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);

                        osc.type = "sine";
                        osc.frequency.setValueAtTime(
                            freq,
                            this.audioContext.currentTime,
                        );

                        const startTime =
                            this.audioContext.currentTime + i * 0.1;
                        gain.gain.setValueAtTime(
                            this.masterVolume * 0.4,
                            startTime,
                        );
                        gain.gain.exponentialRampToValueAtTime(
                            0.01,
                            startTime + 0.15,
                        );

                        osc.start(startTime);
                        osc.stop(startTime + 0.15);
                    });
                }

                playSelect() {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);

                    osc.frequency.setValueAtTime(
                        600,
                        this.audioContext.currentTime,
                    );
                    osc.frequency.exponentialRampToValueAtTime(
                        800,
                        this.audioContext.currentTime + 0.05,
                    );

                    gain.gain.setValueAtTime(
                        this.masterVolume * 0.3,
                        this.audioContext.currentTime,
                    );
                    gain.gain.exponentialRampToValueAtTime(
                        0.01,
                        this.audioContext.currentTime + 0.05,
                    );

                    osc.start(this.audioContext.currentTime);
                    osc.stop(this.audioContext.currentTime + 0.05);
                }

                playHover() {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);

                    osc.frequency.setValueAtTime(
                        400,
                        this.audioContext.currentTime,
                    );

                    gain.gain.setValueAtTime(
                        this.masterVolume * 0.15,
                        this.audioContext.currentTime,
                    );
                    gain.gain.exponentialRampToValueAtTime(
                        0.01,
                        this.audioContext.currentTime + 0.03,
                    );

                    osc.start(this.audioContext.currentTime);
                    osc.stop(this.audioContext.currentTime + 0.03);
                }
            }

            // Initialize sound system
            const soundFX = new SoundFX();

            // Character Select Scene
            class CharacterSelectScene extends Phaser.Scene {
                constructor() {
                    super({ key: "CharacterSelectScene" });
                }

                preload() {
                    // No assets to load
                }

                create() {
                    // Title
                    this.add
                        .text(400, 300, "MAGIC AFFINITY", {
                            fontSize: "48px",
                            fill: "#ffd700",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                        })
                        .setOrigin(0.5);

                    // Auto-start game after 1.5 seconds
                    this.time.delayedCall(1500, () => {
                        gameState.selectedCharacter = "wizard";
                        // Select random season for this run
                        const seasons = ["spring", "summer", "fall", "winter"];
                        gameState.currentSeason =
                            seasons[Math.floor(Math.random() * seasons.length)];
                        this.cameras.main.fade(500, 0, 0, 0);
                        this.time.delayedCall(500, () => {
                            this.scene.start("GameScene");
                        });
                    });

                    // High Score Display
                    if (gameState.highScore > 0) {
                        this.add
                            .text(
                                400,
                                500,
                                `High Score: ${gameState.highScore}`,
                                {
                                    fontSize: "18px",
                                    fill: "#4ecdc4",
                                    fontFamily: "Courier New",
                                },
                            )
                            .setOrigin(0.5);
                    }

                    // Fullscreen button
                    this.createFullscreenButton();
                }

                createFullscreenButton() {
                    const fsButton = this.add
                        .text(750, 20, "‚õ∂", {
                            fontSize: "32px",
                            fill: "#ffffff",
                            fontFamily: "Arial",
                        })
                        .setOrigin(0.5)
                        .setInteractive();

                    fsButton.on("pointerover", () => {
                        fsButton.setScale(1.2);
                        this.input.setDefaultCursor("pointer");
                        soundFX.play("hover");
                    });

                    fsButton.on("pointerout", () => {
                        fsButton.setScale(1);
                        this.input.setDefaultCursor("default");
                    });

                    fsButton.on("pointerdown", () => {
                        soundFX.play("select");
                        if (this.scale.isFullscreen) {
                            this.scale.stopFullscreen();
                        } else {
                            this.scale.startFullscreen();
                        }
                    });
                }

                // Removed old character drawing functions - wizard is now always selected
            }

            // Main Game Scene
            class GameScene extends Phaser.Scene {
                constructor() {
                    super({ key: "GameScene" });
                }

                preload() {
                    // Load background music
                    this.load.audio('bgMusic', 'Here comes trouble!.mp3');
                }

                create() {
                    // Reset game state
                    this.wave = 1;
                    this.enemiesThisWave = 5;
                    this.enemiesSpawned = 0;
                    this.enemiesAlive = 0;
                    this.isBossWave = false;
                    this.waveReadyToStart = false;
                    this.score = 0;
                    this.survivalTime = 0;
                    this.paused = false;

                    // Create tiled grass background
                    this.createBackground();

                    // Start background music
                    if (!this.bgMusic) {
                        this.bgMusic = this.sound.add('bgMusic', {
                            loop: true,
                            volume: 0.3
                        });
                        this.bgMusic.play();
                    }

                    // Initialize groups
                    this.enemies = this.physics.add.group();
                    this.projectiles = this.physics.add.group();
                    this.xpOrbs = this.physics.add.group();
                    this.damageNumbers = [];

                    // Wizard orbs array (always initialize to prevent errors)
                    this.wizardOrbs = [];

                    // Environmental hazards
                    this.hazards = [];

                    // Create player
                    this.createPlayer();

                    // Create UI
                    this.createUI();

                    // Setup input
                    this.cursors = this.input.keyboard.createCursorKeys();
                    this.wKey = this.input.keyboard.addKey(
                        Phaser.Input.Keyboard.KeyCodes.W,
                    );
                    this.aKey = this.input.keyboard.addKey(
                        Phaser.Input.Keyboard.KeyCodes.A,
                    );
                    this.sKey = this.input.keyboard.addKey(
                        Phaser.Input.Keyboard.KeyCodes.S,
                    );
                    this.dKey = this.input.keyboard.addKey(
                        Phaser.Input.Keyboard.KeyCodes.D,
                    );
                    this.spaceKey = this.input.keyboard.addKey(
                        Phaser.Input.Keyboard.KeyCodes.SPACE,
                    );
                    this.pKey = this.input.keyboard.addKey(
                        Phaser.Input.Keyboard.KeyCodes.P,
                    );
                    this.escKey = this.input.keyboard.addKey(
                        Phaser.Input.Keyboard.KeyCodes.ESC,
                    );

                    // Pause menu elements (hidden by default)
                    this.pauseMenuElements = null;

                    // Touch controls for mobile
                    this.touchControls = { x: 0, y: 0, active: false };
                    this.setupTouchControls();

                    // Handle pause key
                    this.pKey.on("down", () => this.togglePause());
                    this.escKey.on("down", () => this.togglePause());

                    // Setup collisions
                    this.physics.add.overlap(
                        this.player,
                        this.enemies,
                        this.playerHitEnemy,
                        null,
                        this,
                    );
                    this.physics.add.overlap(
                        this.projectiles,
                        this.enemies,
                        this.projectileHitEnemy,
                        null,
                        this,
                    );
                    this.physics.add.overlap(
                        this.player,
                        this.xpOrbs,
                        this.collectXP,
                        null,
                        this,
                    );

                    // Summer trees block projectiles (if they exist)
                    if (this.trees) {
                        this.physics.add.collider(
                            this.projectiles,
                            this.trees,
                            (projectile) => {
                                projectile.destroy(); // Projectile blocked by tree
                            },
                        );
                    }

                    // Start first wave
                    this.time.delayedCall(1000, () => this.startWave());

                    // Spawn environmental hazards after a delay
                    this.time.delayedCall(3000, () => this.spawnHazards());

                    // Survival timer
                    this.time.addEvent({
                        delay: 1000,
                        callback: () => {
                            if (!this.paused) {
                                this.survivalTime++;
                                this.updateTimeDisplay();
                            }
                        },
                        loop: true,
                    });

                    // Camera effects
                    this.cameras.main.fadeIn(500);
                }

                createBackground() {
                    const graphics = this.add.graphics();
                    const season = gameState.currentSeason;

                    // Seasonal color palettes
                    const seasonalColors = {
                        spring: {
                            grass: 0x4a7c2e,
                            grassDark: 0x3a6c1e,
                            grassLight: 0x5a8c3e,
                            decoration: 0xff69b4, // Pink flowers
                            name: "Spring",
                        },
                        summer: {
                            grass: 0x8b6914, // Desert sand
                            grassDark: 0x6b4910,
                            grassLight: 0xab8924,
                            decoration: 0xffd700, // Cacti green
                            name: "Summer",
                        },
                        fall: {
                            grass: 0x5a4a2a,
                            grassDark: 0x4a3a1a,
                            grassLight: 0x6a5a3a,
                            decoration: 0xff8c00, // Orange leaves
                            name: "Fall",
                        },
                        winter: {
                            grass: 0xd0d0d0, // Snow/ice
                            grassDark: 0xb0b0b0,
                            grassLight: 0xf0f0f0,
                            decoration: 0x87ceeb, // Ice patches
                            name: "Winter",
                        },
                    };

                    const colors = seasonalColors[season];

                    // Draw tiled ground with seasonal patterns
                    for (let y = 0; y < 600; y += 32) {
                        for (let x = 0; x < 800; x += 32) {
                            // Base tile
                            graphics.fillStyle(colors.grass, 1);
                            graphics.fillRect(x, y, 32, 32);

                            // Seasonal tile details
                            if (season === "spring") {
                                // Grass blades
                                graphics.fillStyle(colors.grassDark, 1);
                                graphics.fillRect(x + 4, y + 4, 2, 6);
                                graphics.fillRect(x + 20, y + 12, 2, 6);
                                graphics.fillRect(x + 12, y + 24, 2, 6);
                                graphics.fillStyle(colors.grassLight, 1);
                                graphics.fillRect(x + 8, y + 8, 2, 4);
                                graphics.fillRect(x + 24, y + 16, 2, 4);
                            } else if (season === "summer") {
                                // Sand dunes pattern
                                graphics.fillStyle(colors.grassDark, 1);
                                graphics.fillRect(x + 2, y + 20, 28, 8);
                                graphics.fillStyle(colors.grassLight, 1);
                                graphics.fillRect(x + 4, y + 4, 24, 8);
                            } else if (season === "fall") {
                                // Dirt patches
                                graphics.fillStyle(colors.grassDark, 1);
                                graphics.fillRect(x + 4, y + 4, 8, 8);
                                graphics.fillRect(x + 20, y + 16, 8, 8);
                                graphics.fillStyle(colors.grassLight, 1);
                                graphics.fillRect(x + 14, y + 24, 6, 6);
                            } else if (season === "winter") {
                                // Ice crystals
                                graphics.fillStyle(colors.grassLight, 1);
                                graphics.fillRect(x + 8, y + 8, 4, 4);
                                graphics.fillRect(x + 20, y + 16, 4, 4);
                                graphics.fillStyle(colors.decoration, 0.3);
                                graphics.fillRect(x + 4, y + 20, 8, 8);
                            }
                        }
                    }

                    // Add seasonal decorations and mechanics
                    if (season === "spring") {
                        // Spring: Many colorful flowers
                        for (let i = 0; i < 40; i++) {
                            const x = Phaser.Math.Between(50, 750);
                            const y = Phaser.Math.Between(50, 550);

                            // Flower petals
                            const flowerColors = [
                                0xff69b4, 0xff1493, 0xffc0cb, 0xff6eb4,
                            ];
                            const color = flowerColors[i % flowerColors.length];

                            graphics.fillStyle(color, 1);
                            graphics.fillCircle(x + 4, y, 3);
                            graphics.fillCircle(x + 8, y, 3);
                            graphics.fillCircle(x + 6, y - 3, 3);
                            graphics.fillCircle(x + 6, y + 3, 3);

                            // Center
                            graphics.fillStyle(0xffd700, 1);
                            graphics.fillCircle(x + 6, y, 2);

                            // Stem
                            graphics.fillStyle(0x2d5016, 1);
                            graphics.fillRect(x + 5, y + 3, 2, 8);
                        }
                    } else if (season === "summer") {
                        // Summer: Trees that block projectiles
                        this.trees = this.physics.add.staticGroup();

                        for (let i = 0; i < 8; i++) {
                            const treeX = Phaser.Math.Between(100, 700);
                            const treeY = Phaser.Math.Between(100, 500);

                            const tree = this.add.graphics();
                            tree.x = treeX;
                            tree.y = treeY;

                            // Tree trunk (brown)
                            tree.fillStyle(0x654321, 1);
                            tree.fillRect(-8, 0, 16, 30);

                            // Tree canopy (green)
                            tree.fillStyle(0x228b22, 1);
                            tree.fillCircle(0, -10, 25);
                            tree.fillCircle(-15, 0, 20);
                            tree.fillCircle(15, 0, 20);

                            // Darker green details
                            tree.fillStyle(0x1a6b1a, 1);
                            tree.fillCircle(-8, -5, 12);
                            tree.fillCircle(8, -5, 12);

                            tree.setDepth(15); // Above game entities

                            // Add physics body for collision
                            this.physics.add.existing(tree, true); // true = static
                            tree.body.setCircle(30, -30, -30);

                            this.trees.add(tree);
                        }
                    } else if (season === "fall") {
                        // Fall: Flying leaves that obscure vision
                        this.fallingLeaves = [];

                        for (let i = 0; i < 30; i++) {
                            const leaf = this.add.graphics();
                            leaf.x = Phaser.Math.Between(0, 800);
                            leaf.y = Phaser.Math.Between(-100, 600);

                            // Brown leaf shape
                            const leafColors = [0x8b4513, 0xa0522d, 0x654321];
                            leaf.fillStyle(leafColors[i % 3], 0.7);

                            // Leaf shape
                            leaf.fillTriangle(-6, 0, 0, -8, 6, 0);
                            leaf.fillTriangle(-6, 0, 0, 8, 6, 0);

                            leaf.setDepth(500); // Above everything except UI

                            // Random float speed
                            leaf.floatSpeed = Phaser.Math.Between(20, 60);
                            leaf.driftSpeed = Phaser.Math.Between(-30, 30);

                            this.fallingLeaves.push(leaf);
                        }
                    } else if (season === "winter") {
                        // Winter: Slippery ice patches
                        this.icePatches = [];

                        for (let i = 0; i < 12; i++) {
                            const icePatch = this.add.graphics();
                            const iceX = Phaser.Math.Between(100, 700);
                            const iceY = Phaser.Math.Between(100, 500);

                            icePatch.x = iceX;
                            icePatch.y = iceY;

                            // Ice patch (light blue, semi-transparent)
                            icePatch.fillStyle(0x87ceeb, 0.6);
                            icePatch.fillCircle(0, 0, 40);

                            // Ice highlights
                            icePatch.fillStyle(0xf0f8ff, 0.8);
                            icePatch.fillCircle(-10, -10, 15);
                            icePatch.fillCircle(12, 8, 12);

                            // Shine effect
                            icePatch.fillStyle(0xffffff, 0.9);
                            icePatch.fillCircle(-5, -8, 6);

                            icePatch.setDepth(5); // Just above ground

                            this.icePatches.push(icePatch);
                        }
                    }

                    // Display season name
                    this.add
                        .text(400, 580, `${colors.name} Map`, {
                            fontSize: "14px",
                            fill: "#ffffff",
                            fontFamily: "Courier New",
                            stroke: "#000000",
                            strokeThickness: 3,
                        })
                        .setOrigin(0.5)
                        .setDepth(1002);
                }

                createPlayer() {
                    // Player is always the wizard now
                    this.player = this.add.graphics();
                    this.player.x = 400;
                    this.player.y = 300;

                    // Draw grey wizard (no element chosen yet)
                    this.drawWizard(this.player);

                    // Wizard stats
                    this.player.maxHealth = 50; // Reduced from 100 for increased difficulty
                    this.player.baseSpeed = 140;
                    this.player.baseDamage = 20;
                    this.player.attackSpeed = 0; // Doesn't use attack speed (uses orbs)
                    this.player.orbCount = 2; // Start with 2 orbs
                    this.player.orbSpeed = 2.5; // Rotation speed (25% faster)
                    this.player.orbDistance = 50; // Distance from player

                    // Element system - starts with no element
                    this.player.element = null; // Will be set on first level up
                    this.player.elementalUpgrades = []; // Track which element upgrades have been taken

                    this.player.health = this.player.maxHealth;
                    this.player.level = 1;
                    this.player.xp = 0;
                    this.player.xpToNext = 100;
                    this.player.speed = this.player.baseSpeed;
                    this.player.damage = this.player.baseDamage;
                    this.player.defense = 5;
                    this.player.characterType = "wizard"; // Always wizard now

                    // Physics
                    this.physics.add.existing(this.player);
                    this.player.body.setSize(20, 20);
                    this.player.body.setCollideWorldBounds(true);

                    // Set depth so player appears behind UI
                    this.player.setDepth(10);

                    // Auto-attack timer
                    this.player.lastAttackTime = 0;

                    // Invulnerability frames
                    this.player.invulnerable = false;
                    this.player.invulnerableTime = 0;

                    // Create wizard orbs (will be grey until element is chosen)
                    this.createWizardOrbs();
                }

                // Archer and Warrior characters removed - Wizard only now

                drawWizard(graphics) {
                    graphics.clear();

                    // Get element color (grey if no element chosen yet)
                    let elementColor = 0x808080; // Grey default
                    if (this.player && this.player.element && ELEMENTS[this.player.element]) {
                        elementColor = ELEMENTS[this.player.element].color;
                    }

                    // Wizard hat (element color or grey)
                    graphics.fillStyle(elementColor, 1);
                    graphics.fillRect(-6, -10, 12, 6);
                    graphics.fillRect(-4, -14, 8, 4);

                    // Hat star
                    graphics.fillStyle(0xffd700, 1);
                    graphics.fillRect(-1, -8, 2, 2);

                    // Face
                    graphics.fillStyle(0xffd4a3, 1);
                    graphics.fillRect(-4, -4, 8, 6);

                    // Eyes
                    graphics.fillStyle(0x4169e1, 1);
                    graphics.fillRect(-3, -2, 2, 2);
                    graphics.fillRect(1, -2, 2, 2);

                    // Beard
                    graphics.fillStyle(0xc0c0c0, 1);
                    graphics.fillRect(-4, 2, 8, 4);

                    // Robe (element color or grey)
                    graphics.fillStyle(elementColor, 1);
                    graphics.fillRect(-5, 6, 10, 10);

                    // Robe trim (gold)
                    graphics.fillStyle(0xffd700, 1);
                    graphics.fillRect(-5, 6, 10, 1);

                    // Arms/sleeves (element color or grey)
                    graphics.fillStyle(elementColor, 1);
                    graphics.fillRect(-7, 8, 2, 6);
                    graphics.fillRect(5, 8, 2, 6);

                    // Hands
                    graphics.fillStyle(0xffd4a3, 1);
                    graphics.fillRect(-7, 13, 2, 2);
                    graphics.fillRect(5, 13, 2, 2);

                    // Staff
                    graphics.fillStyle(0x8b4513, 1);
                    graphics.fillRect(-9, 6, 2, 10);

                    // Staff orb (element color or grey)
                    graphics.fillStyle(elementColor, 1);
                    graphics.fillCircle(-8, 4, 3);
                    graphics.fillStyle(0x87ceeb, 1);
                    graphics.fillCircle(-8, 4, 2);
                }

                createWizardOrbs() {
                    if (!this.player || !this.player.orbCount) {
                        console.warn(
                            "Cannot create wizard orbs: player not ready",
                        );
                        return;
                    }

                    console.log(`Creating ${this.player.orbCount} wizard orbs`);

                    // Get orb color based on element (grey if no element chosen yet)
                    const orbColor = this.player.element ? ELEMENTS[this.player.element].color : 0x808080;

                    // Create the initial wizard orbs
                    for (let i = 0; i < this.player.orbCount; i++) {
                        const orb = this.add.graphics();
                        orb.orbAngle = (i / this.player.orbCount) * Math.PI * 2;

                        // Draw magical orb (grey initially, changes when element is chosen)
                        orb.fillStyle(orbColor, 0.6);
                        orb.fillCircle(0, 0, 10);
                        orb.fillStyle(this.player.element ? orbColor : 0xa0a0a0, 1);
                        orb.fillCircle(0, 0, 6);
                        orb.fillStyle(0xffffff, 1);
                        orb.fillCircle(-2, -2, 2);

                        this.physics.add.existing(orb);
                        orb.body.setCircle(8);
                        orb.setDepth(10);

                        this.wizardOrbs.push(orb);
                    }
                }

                updateOrbColors(color) {
                    // Redraw all existing orbs with the new element color
                    this.wizardOrbs.forEach((orb) => {
                        orb.clear();
                        orb.fillStyle(color, 0.6);
                        orb.fillCircle(0, 0, 10);
                        orb.fillStyle(color, 1);
                        orb.fillCircle(0, 0, 6);
                        orb.fillStyle(0xffffff, 1);
                        orb.fillCircle(-2, -2, 2);
                    });
                }

                updateWizardOrbs() {
                    if (!this.player || this.player.characterType !== "wizard")
                        return;
                    if (!this.wizardOrbs) this.wizardOrbs = [];

                    // Make sure we have the right number of orbs
                    while (this.wizardOrbs.length < this.player.orbCount) {
                        const orb = this.add.graphics();
                        orb.orbAngle =
                            (this.wizardOrbs.length / this.player.orbCount) *
                            Math.PI *
                            2;

                        // Use element color if chosen, otherwise grey
                        const orbColor = this.player.element ? ELEMENTS[this.player.element].color : 0x808080;

                        orb.fillStyle(orbColor, 0.6);
                        orb.fillCircle(0, 0, 10);
                        orb.fillStyle(this.player.element ? orbColor : 0xa0a0a0, 1);
                        orb.fillCircle(0, 0, 6);
                        orb.fillStyle(0xffffff, 1);
                        orb.fillCircle(-2, -2, 2);

                        this.physics.add.existing(orb);
                        orb.body.setCircle(8);
                        orb.setDepth(10);

                        this.wizardOrbs.push(orb);
                    }

                    // Update orb positions
                    this.wizardOrbs.forEach((orb, index) => {
                        orb.orbAngle += this.player.orbSpeed * 0.02;

                        const x =
                            this.player.x +
                            Math.cos(orb.orbAngle) * this.player.orbDistance;
                        const y =
                            this.player.y +
                            Math.sin(orb.orbAngle) * this.player.orbDistance;

                        orb.x = x;
                        orb.y = y;

                        // Check collision with enemies
                        this.enemies.children.entries.forEach((enemy) => {
                            if (!enemy.active) return;

                            const dist = Phaser.Math.Distance.Between(
                                orb.x,
                                orb.y,
                                enemy.x,
                                enemy.y,
                            );
                            if (dist < 18) {
                                this.orbHitEnemy(orb, enemy);
                            }
                        });
                    });
                }

                orbHitEnemy(orb, enemy) {
                    if (!orb || !enemy || !orb.active || !enemy.active) return;

                    // Cooldown check to prevent hitting same enemy too fast
                    const now = this.time.now;
                    if (enemy.lastOrbHit && now - enemy.lastOrbHit < 500)
                        return;
                    enemy.lastOrbHit = now;

                    // Deal damage with element-specific bonuses
                    let damage = this.player.damage;

                    // Molten Core: +25% damage to burning enemies (Flame upgrade)
                    if (this.player.moltenCore && enemy.statusEffects && enemy.statusEffects.burn.active) {
                        damage = Math.floor(damage * this.player.moltenCore);
                    }

                    // Glacial Shards: +30% damage to frozen enemies (Water upgrade)
                    if (this.player.glacialShards && enemy.statusEffects && enemy.statusEffects.freeze.active) {
                        damage = Math.floor(damage * this.player.glacialShards);
                    }

                    // Surge: +30% damage vs tank enemies (Electric upgrade)
                    if (this.player.surge && enemy.isTank) {
                        damage = Math.floor(damage * this.player.surge);
                    } else if (enemy.isTank) {
                        damage = Math.floor(damage * 0.5); // Tanks take 50% less damage normally
                    }

                    enemy.health -= damage;

                    // Show damage number
                    this.showDamageNumber(enemy.x, enemy.y, damage);

                    // Apply elemental status effects based on player's element
                    if (this.player.element && enemy.statusEffects) {
                        const element = this.player.element;
                        const effects = enemy.statusEffects;

                        switch(element) {
                            case 'flame':
                                // Burn: 3 damage/sec for 3 seconds (+ bonuses)
                                effects.burn.active = true;
                                effects.burn.damage = 3 + (this.player.burnDamageBonus || 0);
                                effects.burn.duration = 3000 + (this.player.burnDurationBonus || 0);
                                effects.burn.lastTick = now;
                                break;

                            case 'water':
                                // 50% chance to freeze for 2 seconds (+ bonuses)
                                const freezeChance = 0.50 + (this.player.freezeChanceBonus || 0);
                                if (Math.random() < freezeChance) {
                                    effects.freeze.active = true;
                                    const baseDuration = 2000;
                                    effects.freeze.duration = baseDuration * (this.player.freezeDurationBonus || 1);

                                    // Tidal Wave (Water upgrade) - can freeze 2 enemies at once
                                    if (this.player.hasTidalWave) {
                                        let closestEnemy = null;
                                        let closestDist = 80; // Max tidal wave range
                                        this.enemies.children.entries.forEach((nearbyEnemy) => {
                                            if (nearbyEnemy === enemy || !nearbyEnemy.active) return;
                                            const dist = Phaser.Math.Distance.Between(
                                                enemy.x, enemy.y,
                                                nearbyEnemy.x, nearbyEnemy.y
                                            );
                                            if (dist < closestDist && nearbyEnemy.statusEffects) {
                                                closestDist = dist;
                                                closestEnemy = nearbyEnemy;
                                            }
                                        });

                                        if (closestEnemy && closestEnemy.statusEffects) {
                                            closestEnemy.statusEffects.freeze.active = true;
                                            closestEnemy.statusEffects.freeze.duration = baseDuration * (this.player.freezeDurationBonus || 1);
                                        }
                                    }
                                }
                                break;

                            case 'electric':
                                // 50% chance to paralyze for 1 second (+ bonuses)
                                const paralyzeChance = 0.50 + (this.player.paralyzeChanceBonus || 0);
                                if (Math.random() < paralyzeChance) {
                                    effects.paralyze.active = true;
                                    effects.paralyze.duration = 1000;
                                }

                                // Chain Lightning (Electric upgrade) - jump to nearby enemy
                                if (this.player.hasChainLightning) {
                                    let closestEnemy = null;
                                    let closestDist = 150; // Max chain range
                                    this.enemies.children.entries.forEach((nearbyEnemy) => {
                                        if (nearbyEnemy === enemy || !nearbyEnemy.active) return;
                                        const dist = Phaser.Math.Distance.Between(
                                            enemy.x, enemy.y,
                                            nearbyEnemy.x, nearbyEnemy.y
                                        );
                                        if (dist < closestDist) {
                                            closestDist = dist;
                                            closestEnemy = nearbyEnemy;
                                        }
                                    });

                                    if (closestEnemy) {
                                        // Deal 50% damage to chained enemy
                                        const chainDamage = Math.floor(this.player.damage * 0.5);
                                        closestEnemy.health -= chainDamage;
                                        this.showDamageNumber(closestEnemy.x, closestEnemy.y, chainDamage, 0xffff00);
                                        if (closestEnemy.health <= 0) {
                                            this.killEnemy(closestEnemy);
                                        }
                                    }
                                }
                                break;

                            case 'nature':
                                // Poison: starts at 2 damage (+ bonuses), doubles every 2 seconds
                                effects.poison.active = true;
                                effects.poison.damage = 2 + (this.player.poisonDamageBonus || 0);
                                effects.poison.duration = 6000;
                                effects.poison.lastTick = now;
                                effects.poison.stacks = 0;
                                break;

                            case 'wind':
                                // 50% chance to sleep for 2 seconds (+ bonuses)
                                if (Math.random() < 0.50) {
                                    effects.sleep.active = true;
                                    effects.sleep.duration = 2000 + (this.player.sleepDurationBonus || 0);
                                }
                                // Always apply knockback (+ bonuses)
                                const angle = Phaser.Math.Angle.Between(orb.x, orb.y, enemy.x, enemy.y);
                                const knockbackPower = 200 * (this.player.knockbackBonus || 1);
                                enemy.body.setVelocity(
                                    Math.cos(angle) * knockbackPower,
                                    Math.sin(angle) * knockbackPower
                                );
                                break;

                            case 'terra':
                                // Strong knockback (+ bonuses)
                                const terraAngle = Phaser.Math.Angle.Between(orb.x, orb.y, enemy.x, enemy.y);
                                const terraKnockback = 300 * (this.player.knockbackBonus || 1);
                                enemy.body.setVelocity(
                                    Math.cos(terraAngle) * terraKnockback,
                                    Math.sin(terraAngle) * terraKnockback
                                );
                                // Earthquake: Knockback stuns for 0.5 seconds
                                if (this.player.hasEarthquake) {
                                    effects.paralyze.active = true;
                                    effects.paralyze.duration = 500;
                                }

                                // Tremor (Terra upgrade) - knockback affects area around impact
                                if (this.player.hasTremor) {
                                    this.enemies.children.entries.forEach((nearbyEnemy) => {
                                        if (nearbyEnemy === enemy || !nearbyEnemy.active) return;
                                        const dist = Phaser.Math.Distance.Between(
                                            enemy.x, enemy.y,
                                            nearbyEnemy.x, nearbyEnemy.y
                                        );
                                        if (dist < 80) {
                                            const nearbyAngle = Phaser.Math.Angle.Between(
                                                enemy.x, enemy.y,
                                                nearbyEnemy.x, nearbyEnemy.y
                                            );
                                            const nearbyKnockback = (terraKnockback * 0.5); // Half power for area effect
                                            nearbyEnemy.body.setVelocity(
                                                Math.cos(nearbyAngle) * nearbyKnockback,
                                                Math.sin(nearbyAngle) * nearbyKnockback
                                            );
                                        }
                                    });
                                }
                                break;

                            case 'gravity':
                                // Slow 40% (+ bonuses) + 50% confusion chance
                                effects.slow.active = true;
                                effects.slow.slowAmount = 0.4 + (this.player.slowBonus || 0);
                                if (Math.random() < 0.50) {
                                    effects.confusion.active = true;
                                    effects.confusion.duration = 2000 + (this.player.confusionDurationBonus || 0);
                                }

                                // Dense Matter (Gravity upgrade) - slow affects larger area
                                if (this.player.hasDenseMatter) {
                                    this.enemies.children.entries.forEach((nearbyEnemy) => {
                                        if (nearbyEnemy === enemy || !nearbyEnemy.active || !nearbyEnemy.statusEffects) return;
                                        const dist = Phaser.Math.Distance.Between(
                                            enemy.x, enemy.y,
                                            nearbyEnemy.x, nearbyEnemy.y
                                        );
                                        if (dist < 100) {
                                            nearbyEnemy.statusEffects.slow.active = true;
                                            nearbyEnemy.statusEffects.slow.slowAmount = (0.4 + (this.player.slowBonus || 0)) * 0.5; // Half effectiveness for area
                                        }
                                    });
                                }
                                break;

                            case 'celestial':
                                // 50% charm chance (+ bonuses) for 3 seconds
                                const charmChance = 0.50 + (this.player.charmChanceBonus || 0);
                                if (Math.random() < charmChance) {
                                    effects.charm.active = true;
                                    effects.charm.duration = 3000 + (this.player.charmDurationBonus || 0);
                                }
                                break;

                            case 'radiant':
                                // 50% blind chance (+ bonuses)
                                const blindChance = 0.50 + (this.player.blindChanceBonus || 0);
                                if (Math.random() < blindChance) {
                                    effects.blind.active = true;
                                }
                                break;

                            case 'shadow':
                                // 50% fear (+ bonuses) for 2 seconds
                                const fearChance = 0.50 + (this.player.fearChanceBonus || 0);
                                if (Math.random() < fearChance) {
                                    effects.fear.active = true;
                                    effects.fear.duration = 2000 + (this.player.fearDurationBonus || 0);
                                }
                                break;
                        }
                    }

                    // Play hit sound
                    soundFX.play("hit");

                    // Flash enemy
                    enemy.setAlpha(0.5);
                    this.time.delayedCall(50, () => {
                        if (enemy.active) enemy.setAlpha(1);
                    });

                    // Check if enemy died
                    if (enemy.health <= 0) {
                        this.killEnemy(enemy);
                    }
                }

                updateFlamethrowerAttack(moveX, moveY, time) {
                    // Only fire while moving
                    if (moveX === 0 && moveY === 0) {
                        return;
                    }

                    // Fire cone in opposite direction of movement
                    const fireAngle = Math.atan2(-moveY, -moveX);

                    // Initialize flamethrower timer if needed
                    if (!this.player.lastFlamethrowerTick) {
                        this.player.lastFlamethrowerTick = time;
                    }

                    // Tick damage every 1.5 seconds
                    if (time - this.player.lastFlamethrowerTick >= 1500) {
                        this.player.lastFlamethrowerTick = time;

                        // Create wide cone spray effect
                        const coneAngleSpread = Math.PI / 3; // 60 degree spread
                        const flameRange = 100;

                        // Create fire particles
                        for (let i = 0; i < 8; i++) {
                            const offsetAngle = (i / 8 - 0.5) * coneAngleSpread;
                            const particleAngle = fireAngle + offsetAngle;
                            const px = this.player.x + Math.cos(particleAngle) * (flameRange * 0.5);
                            const py = this.player.y + Math.sin(particleAngle) * (flameRange * 0.5);

                            const particle = this.add.graphics();
                            particle.fillStyle(0xff4500, 0.8);
                            particle.fillCircle(0, 0, Phaser.Math.Between(5, 12));
                            particle.x = px;
                            particle.y = py;
                            particle.setDepth(15);

                            this.tweens.add({
                                targets: particle,
                                x: px + Math.cos(particleAngle) * 30,
                                y: py + Math.sin(particleAngle) * 30,
                                alpha: 0,
                                scale: 0.5,
                                duration: 500,
                                onComplete: () => particle.destroy()
                            });
                        }

                        // Damage enemies in cone
                        this.enemies.children.entries.forEach((enemy) => {
                            if (!enemy.active) return;

                            const toEnemy = Math.atan2(
                                enemy.y - this.player.y,
                                enemy.x - this.player.x
                            );
                            // Calculate angle difference manually (Phaser.Math.Angle.Difference doesn't exist in v3.70.0)
                            let angleDiff = fireAngle - toEnemy;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            angleDiff = Math.abs(angleDiff);

                            const dist = Phaser.Math.Distance.Between(
                                this.player.x, this.player.y,
                                enemy.x, enemy.y
                            );

                            // Check if in cone
                            if (dist < 100 && angleDiff < Math.PI / 3) {
                                // Deal damage
                                const damage = this.player.damage;
                                enemy.health -= damage;
                                this.showDamageNumber(enemy.x, enemy.y, damage, 0xff4500);

                                // Apply burn status effect
                                if (enemy.statusEffects) {
                                    enemy.statusEffects.burn.active = true;
                                    enemy.statusEffects.burn.damage = 3 + (this.player.burnDamageBonus || 0);
                                    enemy.statusEffects.burn.duration = 3000 + (this.player.burnDurationBonus || 0);
                                    enemy.statusEffects.burn.lastTick = time;
                                }

                                // Flash enemy
                                enemy.setAlpha(0.5);
                                this.time.delayedCall(50, () => {
                                    if (enemy.active) enemy.setAlpha(1);
                                });

                                // Check if died
                                if (enemy.health <= 0) {
                                    this.killEnemy(enemy);
                                }
                            }
                        });

                        soundFX.play("hit");
                    }
                }

                updateWaterBulletsAttack(time) {
                    // Initialize bullet timer if needed
                    if (!this.player.lastWaterBulletTime) {
                        this.player.lastWaterBulletTime = time;
                    }

                    // Fire 1 bullet per second
                    if (time - this.player.lastWaterBulletTime >= 1000) {
                        this.player.lastWaterBulletTime = time;

                        // Find nearest enemy (global range)
                        let nearestEnemy = null;
                        let nearestDistance = Infinity;

                        this.enemies.children.entries.forEach((enemy) => {
                            if (!enemy.active) return;
                            const dist = Phaser.Math.Distance.Between(
                                this.player.x, this.player.y,
                                enemy.x, enemy.y
                            );
                            if (dist < nearestDistance) {
                                nearestDistance = dist;
                                nearestEnemy = enemy;
                            }
                        });

                        // Only fire if there's an enemy
                        if (nearestEnemy) {
                            const angle = Math.atan2(
                                nearestEnemy.y - this.player.y,
                                nearestEnemy.x - this.player.x
                            );

                            const bullet = this.add.graphics();
                            bullet.fillStyle(0x4169e1, 0.8);
                            bullet.fillCircle(0, 0, 6);
                            bullet.x = this.player.x;
                            bullet.y = this.player.y;
                            bullet.angle = angle;
                            bullet.canPierce = true; // Allow piercing multiple enemies
                            bullet.damage = 15; // 2 shots kill a slime (30 HP)
                            bullet.setDepth(10);

                            // Add physics
                            this.physics.add.existing(bullet);
                            const bulletSpeed = 300;
                            bullet.body.setVelocity(
                                Math.cos(angle) * bulletSpeed,
                                Math.sin(angle) * bulletSpeed
                            );

                            this.projectiles.add(bullet);

                            soundFX.play("shoot");
                        }
                    }
                }

                updateChainLightningAttack(time) {
                    // Initialize lightning timer if needed
                    if (!this.player.lastLightningTime) {
                        this.player.lastLightningTime = time;
                    }

                    // Fire 1 lightning chain per second
                    if (time - this.player.lastLightningTime >= 1000) {
                        this.player.lastLightningTime = time;

                        // Find nearest enemy within medium range (250 pixels)
                        let nearestEnemy = null;
                        let nearestDistance = 250; // Medium range

                        this.enemies.children.entries.forEach((enemy) => {
                            if (!enemy.active) return;
                            const dist = Phaser.Math.Distance.Between(
                                this.player.x, this.player.y,
                                enemy.x, enemy.y
                            );
                            if (dist < nearestDistance) {
                                nearestDistance = dist;
                                nearestEnemy = enemy;
                            }
                        });

                        // Only fire if there's an enemy in range
                        if (nearestEnemy) {
                            const hitEnemies = new Set();
                            let currentEnemy = nearestEnemy;

                            // Chain lightning
                            for (let chain = 0; chain < 10; chain++) {
                                if (!currentEnemy || !currentEnemy.active) break;

                                // Mark as hit
                                hitEnemies.add(currentEnemy);

                                // Deal damage
                                const damage = this.player.damage;
                                currentEnemy.health -= damage;
                                this.showDamageNumber(currentEnemy.x, currentEnemy.y, damage, 0xffff00);

                                // Apply paralyze status effect
                                if (currentEnemy.statusEffects) {
                                    currentEnemy.statusEffects.paralyze.active = true;
                                    currentEnemy.statusEffects.paralyze.duration = 1500 + (this.player.paralyzeChanceBonus || 0) * 100;
                                }

                                // Flash enemy
                                currentEnemy.setAlpha(0.5);
                                this.time.delayedCall(50, () => {
                                    if (currentEnemy.active) currentEnemy.setAlpha(1);
                                });

                                // Check if died
                                if (currentEnemy.health <= 0) {
                                    this.killEnemy(currentEnemy);
                                }

                                // Find next nearest enemy to chain to (from current enemy's position)
                                let nextEnemy = null;
                                let nextDistance = 250; // Medium range for chain

                                this.enemies.children.entries.forEach((enemy) => {
                                    if (!enemy.active || hitEnemies.has(enemy)) return;
                                    const dist = Phaser.Math.Distance.Between(
                                        currentEnemy.x, currentEnemy.y,
                                        enemy.x, enemy.y
                                    );
                                    if (dist < nextDistance) {
                                        nextDistance = dist;
                                        nextEnemy = enemy;
                                    }
                                });

                                // Draw lightning bolt from current to next
                                if (nextEnemy) {
                                    const lightning = this.add.graphics();
                                    lightning.lineStyle(3, 0xffff00, 0.8);
                                    lightning.beginPath();
                                    lightning.moveTo(currentEnemy.x, currentEnemy.y);
                                    lightning.lineTo(nextEnemy.x, nextEnemy.y);
                                    lightning.strokePath();
                                    lightning.setDepth(15);

                                    this.time.delayedCall(100, () => {
                                        if (lightning) lightning.destroy();
                                    });

                                    currentEnemy = nextEnemy;
                                } else {
                                    break; // No more enemies to chain to
                                }
                            }

                            soundFX.play("hit");
                        }
                    }
                }

                updateSeedPlanting(moveX, moveY, time) {
                    // Initialize seed system if needed
                    if (!this.playerSeeds) {
                        this.playerSeeds = [];
                    }

                    // Only plant while moving
                    if (moveX === 0 && moveY === 0) {
                        return;
                    }

                    // Initialize seed planting timer if needed
                    if (!this.player.lastSeedPlantTime) {
                        this.player.lastSeedPlantTime = time;
                    }

                    // Plant seed every 2 seconds
                    if (time - this.player.lastSeedPlantTime >= 2000) {
                        this.player.lastSeedPlantTime = time;

                        const seed = {
                            x: this.player.x,
                            y: this.player.y,
                            plantedTime: time,
                            graphic: null
                        };

                        // Create visual seed (plant sprout)
                        const seedGraphic = this.add.graphics();
                        seedGraphic.fillStyle(0x228b22, 1); // Forest green

                        // Draw plant sprout (stem)
                        seedGraphic.fillRect(-1, -8, 2, 8);

                        // Draw leaves
                        seedGraphic.fillRect(-4, -6, 3, 3);
                        seedGraphic.fillRect(1, -6, 3, 3);
                        seedGraphic.fillRect(-3, -3, 2, 2);
                        seedGraphic.fillRect(1, -3, 2, 2);

                        seedGraphic.x = seed.x;
                        seedGraphic.y = seed.y;
                        seedGraphic.setDepth(5);

                        seed.graphic = seedGraphic;
                        this.playerSeeds.push(seed);

                        soundFX.play("xpCollect"); // Use plant sound
                    }
                }

                updateSeedExplosions(time) {
                    if (!this.playerSeeds) {
                        this.playerSeeds = [];
                    }

                    // Check each seed for explosion timing
                    for (let i = this.playerSeeds.length - 1; i >= 0; i--) {
                        const seed = this.playerSeeds[i];

                        // Explode after 2 seconds on ground
                        if (time - seed.plantedTime >= 2000) {
                            // Explosion particles (green leaves flying)
                            for (let j = 0; j < 12; j++) {
                                const particle = this.add.graphics();
                                particle.fillStyle(0x228b22, 0.9);
                                particle.fillCircle(0, 0, Phaser.Math.Between(2, 5));
                                particle.x = seed.x;
                                particle.y = seed.y;
                                particle.setDepth(15);

                                const angle = (j / 12) * Math.PI * 2;
                                const distance = 60;

                                this.tweens.add({
                                    targets: particle,
                                    x: seed.x + Math.cos(angle) * distance,
                                    y: seed.y + Math.sin(angle) * distance,
                                    alpha: 0,
                                    duration: 400,
                                    onComplete: () => particle.destroy()
                                });
                            }

                            // Damage enemies in explosion radius (100 pixels)
                            this.enemies.children.entries.forEach((enemy) => {
                                if (!enemy.active) return;

                                const dist = Phaser.Math.Distance.Between(
                                    seed.x, seed.y,
                                    enemy.x, enemy.y
                                );

                                // Check if in explosion radius
                                if (dist < 100) {
                                    // Deal damage - exactly 30 to kill slime in 1 shot
                                    const damage = 30;
                                    enemy.health -= damage;
                                    this.showDamageNumber(enemy.x, enemy.y, damage, 0x228b22);

                                    // Apply poison status effect
                                    if (enemy.statusEffects) {
                                        enemy.statusEffects.poison.active = true;
                                        enemy.statusEffects.poison.damage = 2 + (this.player.poisonDamageBonus || 0);
                                        enemy.statusEffects.poison.duration = 2000;
                                        enemy.statusEffects.poison.lastTick = time;
                                    }

                                    // Flash enemy
                                    enemy.setAlpha(0.5);
                                    this.time.delayedCall(50, () => {
                                        if (enemy.active) enemy.setAlpha(1);
                                    });

                                    // Check if died
                                    if (enemy.health <= 0) {
                                        this.killEnemy(enemy);
                                    }
                                }
                            });

                            // Destroy seed graphic and remove from array
                            if (seed.graphic && seed.graphic.destroy) {
                                seed.graphic.destroy();
                            }
                            this.playerSeeds.splice(i, 1);

                            soundFX.play("hit");
                        }
                    }
                }

                updateWindBoomerangAttack(time) {
                    // Initialize wind boomerang system if needed
                    if (!this.windBoomerangs) {
                        this.windBoomerangs = [];
                    }

                    // Initialize boomerang timer
                    if (!this.player.lastBoomerangTime) {
                        this.player.lastBoomerangTime = time;
                    }

                    // Fire boomerang every 3 seconds
                    if (time - this.player.lastBoomerangTime >= 3000) {
                        this.player.lastBoomerangTime = time;

                        const boomerang = {
                            x: this.player.x,
                            y: this.player.y,
                            startX: this.player.x,
                            startY: this.player.y,
                            angle: Math.random() * Math.PI * 2, // Random direction
                            progress: 0, // 0 to 1 (0=start, 0.5=max distance, 1=return to start)
                            maxDistance: this.scale.width / 3, // 1/3 screen distance
                            graphic: null,
                            hitEnemies: new Set(), // Track hit enemies for this boomerang
                            spawnTime: time
                        };

                        // Create boomerang visual (grey curved shape)
                        const boomerangGraphic = this.add.graphics();
                        boomerangGraphic.fillStyle(0x888888, 1); // Grey
                        boomerangGraphic.fillCircle(0, 0, 6); // Main body
                        boomerangGraphic.fillCircle(8, 0, 4); // Wing

                        boomerang.graphic = boomerangGraphic;
                        this.windBoomerangs.push(boomerang);

                        soundFX.play("hit"); // Boomerang launch sound
                    }

                    // Update existing boomerangs
                    for (let i = this.windBoomerangs.length - 1; i >= 0; i--) {
                        const boomerang = this.windBoomerangs[i];
                        const boomerangAge = time - boomerang.spawnTime;
                        const totalTravelTime = 2000; // 2 seconds total journey (out and back)

                        boomerang.progress = (boomerangAge % totalTravelTime) / totalTravelTime;

                        let distance;
                        if (boomerang.progress < 0.5) {
                            // Going out
                            distance = boomerang.maxDistance * (boomerang.progress * 2);
                        } else {
                            // Coming back
                            distance = boomerang.maxDistance * (2 - boomerang.progress * 2);
                        }

                        // Calculate position with curved trajectory (sine wave)
                        boomerang.x = boomerang.startX + Math.cos(boomerang.angle) * distance;
                        boomerang.y = boomerang.startY + Math.sin(boomerang.angle) * distance;

                        // Add curve based on progress (parabolic arc)
                        const curveAmount = Math.sin(boomerang.progress * Math.PI) * 30;
                        boomerang.x += Math.sin(boomerang.angle + Math.PI / 2) * curveAmount;
                        boomerang.y += Math.cos(boomerang.angle + Math.PI / 2) * curveAmount;

                        // Update boomerang position and rotation
                        if (boomerang.graphic) {
                            boomerang.graphic.x = boomerang.x;
                            boomerang.graphic.y = boomerang.y;
                            boomerang.graphic.rotation += 0.1; // Spinning effect

                            // Check collision with enemies
                            this.enemies.children.entries.forEach((enemy) => {
                                if (!enemy.active) return;

                                const dist = Phaser.Math.Distance.Between(
                                    boomerang.x, boomerang.y,
                                    enemy.x, enemy.y
                                );

                                // Hit if within 15 pixels and not already hit (immunity system)
                                if (dist < 15 && !boomerang.hitEnemies.has(enemy)) {
                                    boomerang.hitEnemies.add(enemy);

                                    // Deal 15 damage
                                    const damage = 15;
                                    enemy.health -= damage;
                                    this.showDamageNumber(enemy.x, enemy.y, damage, 0x87ceeb);

                                    // Flash enemy
                                    enemy.setAlpha(0.5);
                                    this.time.delayedCall(50, () => {
                                        if (enemy.active) enemy.setAlpha(1);
                                    });

                                    // Apply 0.5 second immunity timer to prevent stacking
                                    const hitTime = time;
                                    const checkImmunity = () => {
                                        if (time - hitTime < 500) {
                                            // Still immune - don't allow re-hitting in same boomerang pass
                                        } else {
                                            // Immunity expired - this enemy can be hit again by future boomerangs
                                            boomerang.hitEnemies.delete(enemy);
                                        }
                                    };

                                    // Check if died
                                    if (enemy.health <= 0) {
                                        this.killEnemy(enemy);
                                    }

                                    soundFX.play("hit");
                                }
                            });
                        }

                        // Remove boomerang after returning (3 seconds total: 2 sec travel + 1 sec buffer)
                        if (boomerangAge >= 3000) {
                            if (boomerang.graphic && boomerang.graphic.destroy) {
                                boomerang.graphic.destroy();
                            }
                            this.windBoomerangs.splice(i, 1);
                        }
                    }
                }

                updateTerrainWalls(moveX, moveY, time) {
                    // Initialize wall system if needed
                    if (!this.playerWalls) {
                        this.playerWalls = [];
                    }

                    // Initialize wall spawn timer
                    if (!this.player.lastWallSpawnTime) {
                        this.player.lastWallSpawnTime = time;
                    }

                    // Spawn wall every 2 seconds
                    if (time - this.player.lastWallSpawnTime >= 2000) {
                        this.player.lastWallSpawnTime = time;

                        // Random distance between 80-200 pixels
                        const spawnDistance = Phaser.Math.Between(80, 200);
                        const spawnAngle = Math.random() * Math.PI * 2;

                        const wall = {
                            x: this.player.x + Math.cos(spawnAngle) * spawnDistance,
                            y: this.player.y + Math.sin(spawnAngle) * spawnDistance,
                            width: 40,
                            height: 40,
                            spawnTime: time,
                            graphic: null,
                            physicsBody: null,
                            hitEnemies: new Set() // Track enemies hit during spawn phase
                        };

                        // Create wall visual (brown stone)
                        const wallGraphic = this.add.graphics();
                        wallGraphic.fillStyle(0x8b4513, 1); // Brown stone
                        wallGraphic.fillRect(-wall.width / 2, -wall.height / 2, wall.width, wall.height);

                        // Add stone texture (simple cracks)
                        wallGraphic.lineStyle(1, 0x654321, 0.5);
                        wallGraphic.beginPath();
                        wallGraphic.moveTo(-15, -10);
                        wallGraphic.lineTo(10, 15);
                        wallGraphic.stroke();
                        wallGraphic.beginPath();
                        wallGraphic.moveTo(-10, 15);
                        wallGraphic.lineTo(15, -10);
                        wallGraphic.stroke();

                        wallGraphic.x = wall.x;
                        wallGraphic.y = wall.y;
                        wallGraphic.setDepth(10);

                        // Create physics body for collision
                        const wallPhysics = this.physics.add.staticGroup();
                        const wallBody = wallPhysics.create(wall.x, wall.y);
                        wallBody.setSize(wall.width, wall.height);
                        wallBody.setBounce(0, 0);

                        wall.graphic = wallGraphic;
                        wall.physicsBody = wallPhysics;
                        this.playerWalls.push(wall);

                        soundFX.play("xpCollect"); // Wall creation sound
                    }

                    // Update existing walls
                    for (let i = this.playerWalls.length - 1; i >= 0; i--) {
                        const wall = this.playerWalls[i];
                        const wallAge = time - wall.spawnTime;
                        const spawnDuration = 5000; // 5 seconds spawn phase
                        const staticDuration = 10000; // 10 seconds static phase
                        const totalDuration = spawnDuration + staticDuration; // 15 seconds total

                        if (wallAge < spawnDuration) {
                            // SPAWN PHASE: Wall is spawning and can damage enemies
                            const spawnProgress = wallAge / spawnDuration;

                            // Scale up the wall during spawn
                            const scale = 0.3 + spawnProgress * 0.7;
                            if (wall.graphic) {
                                wall.graphic.setScale(scale);
                                // Pulsing effect during spawn
                                wall.graphic.setAlpha(0.7 + Math.sin(spawnProgress * Math.PI * 4) * 0.3);
                            }

                            // Deal damage to enemies during spawn phase
                            this.enemies.children.entries.forEach((enemy) => {
                                if (!enemy.active) return;

                                const dist = Phaser.Math.Distance.Between(
                                    wall.x, wall.y,
                                    enemy.x, enemy.y
                                );

                                // Hit if within wall radius (60 pixels from center) and not already hit
                                if (dist < 40 && !wall.hitEnemies.has(enemy)) {
                                    wall.hitEnemies.add(enemy);

                                    // Deal 30 damage during spawn
                                    const damage = 30;
                                    enemy.health -= damage;
                                    this.showDamageNumber(enemy.x, enemy.y, damage, 0x8b4513);

                                    // Flash enemy
                                    enemy.setAlpha(0.5);
                                    this.time.delayedCall(50, () => {
                                        if (enemy.active) enemy.setAlpha(1);
                                    });

                                    // Check if died
                                    if (enemy.health <= 0) {
                                        this.killEnemy(enemy);
                                    }

                                    soundFX.play("hit");
                                }
                            });
                        } else if (wallAge < totalDuration) {
                            // STATIC PHASE: Wall is solid barrier, blocks movement
                            if (wall.graphic) {
                                wall.graphic.setAlpha(1); // Full opacity
                                wall.graphic.setScale(1); // Full size
                            }

                            // Check collision with player
                            const playerDist = Phaser.Math.Distance.Between(
                                this.player.x, this.player.y,
                                wall.x, wall.y
                            );

                            if (playerDist < 40) {
                                // Push player away from wall
                                const angle = Math.atan2(
                                    this.player.y - wall.y,
                                    this.player.x - wall.x
                                );

                                this.player.x = wall.x + Math.cos(angle) * 50;
                                this.player.y = wall.y + Math.sin(angle) * 50;

                                // Also stop player velocity to prevent push-through
                                this.player.setVelocity(0, 0);
                            }

                            // Block enemy movement through wall
                            this.enemies.children.entries.forEach((enemy) => {
                                if (!enemy.active) return;

                                const enemyDist = Phaser.Math.Distance.Between(
                                    enemy.x, enemy.y,
                                    wall.x, wall.y
                                );

                                if (enemyDist < 40) {
                                    // Push enemy away from wall
                                    const angle = Math.atan2(
                                        enemy.y - wall.y,
                                        enemy.x - wall.x
                                    );

                                    enemy.x = wall.x + Math.cos(angle) * 50;
                                    enemy.y = wall.y + Math.sin(angle) * 50;
                                    enemy.setVelocity(0, 0);
                                }
                            });
                        } else {
                            // DESPAWN PHASE: Wall is gone
                            if (wall.graphic && wall.graphic.destroy) {
                                wall.graphic.destroy();
                            }
                            if (wall.physicsBody) {
                                wall.physicsBody.destroy();
                            }
                            this.playerWalls.splice(i, 1);
                        }
                    }
                }

                createUI() {
                    // UI Background
                    const uiGraphics = this.add.graphics();
                    uiGraphics.fillStyle(0x0f0f1e, 0.9);
                    uiGraphics.fillRect(10, 10, 300, 100);
                    uiGraphics.lineStyle(2, 0x4a4a5a, 1);
                    uiGraphics.strokeRect(10, 10, 300, 100);
                    uiGraphics.setDepth(1000); // High depth to stay on top

                    // Character name (will update when element is chosen)
                    this.charNameText = this.add
                        .text(20, 20, "WIZARD", {
                            fontSize: "16px",
                            fill: "#ffd700",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                        })
                        .setDepth(1001);

                    // Level
                    this.levelText = this.add
                        .text(20, 40, "Level: 1", {
                            fontSize: "14px",
                            fill: "#ffffff",
                            fontFamily: "Courier New",
                        })
                        .setDepth(1001);

                    // HP Bar
                    this.add
                        .text(20, 60, "HP", {
                            fontSize: "12px",
                            fill: "#ffffff",
                            fontFamily: "Courier New",
                        })
                        .setDepth(1001);

                    this.hpBarBg = this.add.graphics();
                    this.hpBarBg.fillStyle(0x8b0000, 1);
                    this.hpBarBg.fillRect(50, 62, 250, 10);
                    this.hpBarBg.setDepth(1000);

                    this.hpBar = this.add.graphics();
                    this.hpBar.setDepth(1001);

                    // XP Bar
                    this.add
                        .text(20, 80, "XP", {
                            fontSize: "12px",
                            fill: "#ffffff",
                            fontFamily: "Courier New",
                        })
                        .setDepth(1001);

                    this.xpBarBg = this.add.graphics();
                    this.xpBarBg.fillStyle(0x00008b, 1);
                    this.xpBarBg.fillRect(50, 82, 250, 10);
                    this.xpBarBg.setDepth(1000);

                    this.xpBar = this.add.graphics();
                    this.xpBar.setDepth(1001);

                    // Wave and Score info (top right)
                    const rightUIGraphics = this.add.graphics();
                    rightUIGraphics.fillStyle(0x0f0f1e, 0.9);
                    rightUIGraphics.fillRect(490, 10, 300, 80);
                    rightUIGraphics.lineStyle(2, 0x4a4a5a, 1);
                    rightUIGraphics.strokeRect(490, 10, 300, 80);
                    rightUIGraphics.setDepth(1000);

                    this.waveText = this.add
                        .text(500, 20, "Wave: 1", {
                            fontSize: "18px",
                            fill: "#ff6b6b",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                        })
                        .setDepth(1001);

                    this.scoreText = this.add
                        .text(500, 45, "Score: 0", {
                            fontSize: "16px",
                            fill: "#4ecdc4",
                            fontFamily: "Courier New",
                        })
                        .setDepth(1001);

                    this.timeText = this.add
                        .text(500, 65, "Time: 0:00", {
                            fontSize: "14px",
                            fill: "#ffffff",
                            fontFamily: "Courier New",
                        })
                        .setDepth(1001);

                    // Update bars
                    this.updateHealthBar();
                    this.updateXPBar();
                }

                updateHealthBar() {
                    this.hpBar.clear();
                    const healthPercent =
                        this.player.health / this.player.maxHealth;

                    let color = 0xff0000;
                    if (healthPercent > 0.5) color = 0x00ff00;
                    else if (healthPercent > 0.25) color = 0xffa500;

                    this.hpBar.fillStyle(color, 1);
                    this.hpBar.fillRect(50, 62, 250 * healthPercent, 10);
                }

                updateXPBar() {
                    this.xpBar.clear();
                    const xpPercent = this.player.xp / this.player.xpToNext;

                    this.xpBar.fillStyle(0x4169e1, 1);
                    this.xpBar.fillRect(50, 82, 250 * xpPercent, 10);
                }

                updateTimeDisplay() {
                    const minutes = Math.floor(this.survivalTime / 60);
                    const seconds = this.survivalTime % 60;
                    this.timeText.setText(
                        `Time: ${minutes}:${seconds < 10 ? "0" : ""}${seconds}`,
                    );
                }

                setupTouchControls() {
                    // Only show on touch devices
                    if (!("ontouchstart" in window)) return;

                    // Virtual joystick base (bottom left)
                    const joystickBase = this.add.graphics();
                    joystickBase.fillStyle(0x333333, 0.5);
                    joystickBase.fillCircle(100, 500, 50);
                    joystickBase.lineStyle(3, 0x666666, 0.8);
                    joystickBase.strokeCircle(100, 500, 50);
                    joystickBase.setDepth(1500);
                    joystickBase.setScrollFactor(0);

                    // Virtual joystick stick
                    this.joystickStick = this.add.graphics();
                    this.joystickStick.fillStyle(0x00ff88, 0.7);
                    this.joystickStick.fillCircle(100, 500, 25);
                    this.joystickStick.setDepth(1501);
                    this.joystickStick.setScrollFactor(0);

                    this.joystickBaseX = 100;
                    this.joystickBaseY = 500;

                    // Touch input
                    this.input.on("pointerdown", (pointer) => {
                        if (this.paused) return;
                        const dist = Phaser.Math.Distance.Between(
                            pointer.x,
                            pointer.y,
                            this.joystickBaseX,
                            this.joystickBaseY,
                        );
                        if (dist < 80) {
                            this.touchControls.active = true;
                            this.updateJoystick(pointer);
                        }
                    });

                    this.input.on("pointermove", (pointer) => {
                        if (this.touchControls.active && !this.paused) {
                            this.updateJoystick(pointer);
                        }
                    });

                    this.input.on("pointerup", () => {
                        this.touchControls.active = false;
                        this.touchControls.x = 0;
                        this.touchControls.y = 0;
                        // Reset joystick position
                        this.joystickStick.clear();
                        this.joystickStick.fillStyle(0x00ff88, 0.7);
                        this.joystickStick.fillCircle(
                            this.joystickBaseX,
                            this.joystickBaseY,
                            25,
                        );
                    });
                }

                updateJoystick(pointer) {
                    const deltaX = pointer.x - this.joystickBaseX;
                    const deltaY = pointer.y - this.joystickBaseY;
                    const distance = Math.sqrt(
                        deltaX * deltaX + deltaY * deltaY,
                    );
                    const maxDistance = 40;

                    if (distance > maxDistance) {
                        const angle = Math.atan2(deltaY, deltaX);
                        this.touchControls.x = Math.cos(angle);
                        this.touchControls.y = Math.sin(angle);

                        this.joystickStick.clear();
                        this.joystickStick.fillStyle(0x00ff88, 0.7);
                        this.joystickStick.fillCircle(
                            this.joystickBaseX + Math.cos(angle) * maxDistance,
                            this.joystickBaseY + Math.sin(angle) * maxDistance,
                            25,
                        );
                    } else {
                        this.touchControls.x = deltaX / maxDistance;
                        this.touchControls.y = deltaY / maxDistance;

                        this.joystickStick.clear();
                        this.joystickStick.fillStyle(0x00ff88, 0.7);
                        this.joystickStick.fillCircle(pointer.x, pointer.y, 25);
                    }
                }

                togglePause() {
                    // Don't allow pausing during level up screen
                    if (this.paused && this.pauseMenuElements === null) return;

                    if (this.paused && this.pauseMenuElements) {
                        // Unpause
                        this.paused = false;
                        this.physics.resume();
                        this.hidePauseMenu();
                    } else if (!this.paused) {
                        // Pause
                        this.paused = true;
                        this.physics.pause();
                        this.showPauseMenu();
                    }
                }

                showPauseMenu() {
                    this.pauseMenuElements = [];

                    // Dark overlay
                    const overlay = this.add.graphics();
                    overlay.fillStyle(0x000000, 0.85);
                    overlay.fillRect(0, 0, 800, 600);
                    overlay.setDepth(2000);
                    this.pauseMenuElements.push(overlay);

                    // Title
                    const title = this.add
                        .text(400, 150, "PAUSED", {
                            fontSize: "64px",
                            fill: "#ffffff",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                        })
                        .setOrigin(0.5)
                        .setDepth(2001);
                    this.pauseMenuElements.push(title);

                    // Instructions
                    const instructions = this.add
                        .text(400, 250, "Press ESC or P to Resume", {
                            fontSize: "20px",
                            fill: "#cccccc",
                            fontFamily: "Courier New",
                        })
                        .setOrigin(0.5)
                        .setDepth(2001);
                    this.pauseMenuElements.push(instructions);

                    // Resume button
                    const resumeBtn = this.add
                        .text(400, 340, "RESUME", {
                            fontSize: "28px",
                            fill: "#00ff88",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                            backgroundColor: "#1a1a2a",
                            padding: { x: 30, y: 15 },
                        })
                        .setOrigin(0.5)
                        .setDepth(2001)
                        .setInteractive();

                    resumeBtn.on("pointerover", () => {
                        resumeBtn.setFill("#ffffff");
                        this.input.setDefaultCursor("pointer");
                        soundFX.play("hover");
                    });

                    resumeBtn.on("pointerout", () => {
                        resumeBtn.setFill("#00ff88");
                        this.input.setDefaultCursor("default");
                    });

                    resumeBtn.on("pointerdown", () => {
                        soundFX.play("select");
                        this.togglePause();
                    });

                    this.pauseMenuElements.push(resumeBtn);

                    // Quit button
                    const quitBtn = this.add
                        .text(400, 420, "QUIT TO MENU", {
                            fontSize: "24px",
                            fill: "#ff6b6b",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                            backgroundColor: "#1a1a2a",
                            padding: { x: 20, y: 10 },
                        })
                        .setOrigin(0.5)
                        .setDepth(2001)
                        .setInteractive();

                    quitBtn.on("pointerover", () => {
                        quitBtn.setFill("#ffffff");
                        this.input.setDefaultCursor("pointer");
                        soundFX.play("hover");
                    });

                    quitBtn.on("pointerout", () => {
                        quitBtn.setFill("#ff6b6b");
                        this.input.setDefaultCursor("default");
                    });

                    quitBtn.on("pointerdown", () => {
                        soundFX.play("select");
                        this.quitToMenu();
                    });

                    this.pauseMenuElements.push(quitBtn);
                }

                hidePauseMenu() {
                    if (this.pauseMenuElements) {
                        this.pauseMenuElements.forEach((element) => {
                            if (element && element.destroy) {
                                element.destroy();
                            }
                        });
                        this.pauseMenuElements = null;
                    }
                }

                quitToMenu() {
                    // Cleanup
                    this.hidePauseMenu();
                    if (this.wizardOrbs) {
                        this.wizardOrbs.forEach((orb) => {
                            if (orb && orb.destroy) orb.destroy();
                        });
                        this.wizardOrbs = [];
                    }

                    // Clean up boss health bar
                    if (this.bossHealthBarBg) this.bossHealthBarBg.destroy();
                    if (this.bossHealthBar) this.bossHealthBar.destroy();
                    if (this.bossNameText) this.bossNameText.destroy();

                    // Return to character select
                    this.scene.start("CharacterSelectScene");
                }

                updateBossHealthBar(boss) {
                    // Create boss health bar if it doesn't exist
                    if (!this.bossHealthBarBg) {
                        // Background
                        this.bossHealthBarBg = this.add.graphics();
                        this.bossHealthBarBg.fillStyle(0x1a1a1a, 0.9);
                        this.bossHealthBarBg.fillRect(200, 110, 400, 40);
                        this.bossHealthBarBg.lineStyle(3, 0xff0000, 1);
                        this.bossHealthBarBg.strokeRect(200, 110, 400, 40);
                        this.bossHealthBarBg.setDepth(1000);

                        // Boss name
                        this.bossNameText = this.add
                            .text(400, 115, "üî• BOSS üî•", {
                                fontSize: "16px",
                                fill: "#ff0000",
                                fontFamily: "Courier New",
                                fontStyle: "bold",
                            })
                            .setOrigin(0.5, 0)
                            .setDepth(1001);

                        // Health bar
                        this.bossHealthBar = this.add.graphics();
                        this.bossHealthBar.setDepth(1001);
                    }

                    // Update boss health bar
                    const healthPercent = boss.health / boss.maxHealth;
                    this.bossHealthBar.clear();

                    // Color gradient based on health
                    let color = 0xff0000;
                    if (healthPercent > 0.6) color = 0xff6b00;
                    else if (healthPercent > 0.3) color = 0xff0000;
                    else color = 0x8b0000;

                    this.bossHealthBar.fillStyle(color, 1);
                    this.bossHealthBar.fillRect(
                        205,
                        132,
                        390 * healthPercent,
                        13,
                    );

                    // Pulsing effect for low health
                    if (healthPercent < 0.3) {
                        const pulse = Math.sin(Date.now() / 100) * 0.2 + 0.8;
                        this.bossHealthBar.setAlpha(pulse);
                    } else {
                        this.bossHealthBar.setAlpha(1);
                    }
                }

                startWave() {
                    this.waveText.setText(`Wave: ${this.wave}`);
                    this.enemiesSpawned = 0;
                    this.enemiesAlive = 0;

                    // Relocate hazards to new positions each wave
                    if (this.wave > 1 && this.hazards && this.hazards.length > 0) {
                        this.repositionHazards();
                    }

                    // Check if this is a boss wave (every 5 waves)
                    const isBossWave = this.wave % 5 === 0;
                    this.isBossWave = isBossWave;

                    if (isBossWave) {
                        // Boss wave! Spawn boss first
                        this.spawnBoss();
                        // Only spawn 3 additional regular enemies with boss
                        const additionalEnemies = 3;

                        // Spawn additional enemies over time (if any)
                        if (additionalEnemies > 0) {
                            this.time.addEvent({
                                delay: 800,
                                callback: () => {
                                    if (
                                        this.enemiesSpawned <
                                            additionalEnemies &&
                                        !this.paused
                                    ) {
                                        this.spawnEnemy();
                                        this.enemiesSpawned++;
                                    }
                                },
                                repeat: additionalEnemies - 1,
                            });
                        }
                    } else {
                        // Regular wave - spawn enemies over time
                        this.time.addEvent({
                            delay: 800,
                            callback: () => {
                                if (
                                    this.enemiesSpawned <
                                        this.enemiesThisWave &&
                                    !this.paused
                                ) {
                                    this.spawnEnemy();
                                    this.enemiesSpawned++;
                                }
                            },
                            repeat: this.enemiesThisWave - 1,
                        });
                    }
                }

                updateStatusEffects(enemy, time, delta) {
                    if (!enemy.statusEffects) return;

                    const effects = enemy.statusEffects;

                    // BURN - Damage over time
                    if (effects.burn.active) {
                        if (time - effects.burn.lastTick >= effects.burn.tickRate) {
                            enemy.health -= effects.burn.damage;
                            this.showDamageNumber(enemy.x, enemy.y, effects.burn.damage, 0xff4500);
                            effects.burn.lastTick = time;

                            // Wildfire (Flame upgrade) - burn spreads to nearby enemies
                            if (this.player.hasWildfire) {
                                this.enemies.children.entries.forEach((nearbyEnemy) => {
                                    if (nearbyEnemy === enemy || !nearbyEnemy.active) return;
                                    const dist = Phaser.Math.Distance.Between(
                                        enemy.x, enemy.y,
                                        nearbyEnemy.x, nearbyEnemy.y
                                    );
                                    if (dist < 60 && nearbyEnemy.statusEffects && !nearbyEnemy.statusEffects.burn.active) {
                                        nearbyEnemy.statusEffects.burn.active = true;
                                        nearbyEnemy.statusEffects.burn.damage = effects.burn.damage;
                                        nearbyEnemy.statusEffects.burn.duration = 2000; // Shorter spread duration
                                        nearbyEnemy.statusEffects.burn.lastTick = time;
                                    }
                                });
                            }
                        }
                        effects.burn.duration -= delta;
                        if (effects.burn.duration <= 0) {
                            effects.burn.active = false;
                        }
                    }

                    // POISON - Doubling damage over time
                    if (effects.poison.active) {
                        if (time - effects.poison.lastTick >= effects.poison.tickRate) {
                            const damage = effects.poison.damage * Math.pow(2, effects.poison.stacks);
                            enemy.health -= damage;
                            this.showDamageNumber(enemy.x, enemy.y, damage, 0x32cd32);
                            effects.poison.lastTick = time;
                            effects.poison.stacks++; // Double on next tick

                            // Spore Cloud (Nature upgrade) - poison spreads to nearby enemies
                            if (this.player.hasSporeCloud) {
                                this.enemies.children.entries.forEach((nearbyEnemy) => {
                                    if (nearbyEnemy === enemy || !nearbyEnemy.active) return;
                                    const dist = Phaser.Math.Distance.Between(
                                        enemy.x, enemy.y,
                                        nearbyEnemy.x, nearbyEnemy.y
                                    );
                                    if (dist < 60 && nearbyEnemy.statusEffects && !nearbyEnemy.statusEffects.poison.active) {
                                        nearbyEnemy.statusEffects.poison.active = true;
                                        nearbyEnemy.statusEffects.poison.damage = effects.poison.damage;
                                        nearbyEnemy.statusEffects.poison.duration = 3000; // Shorter spread duration
                                        nearbyEnemy.statusEffects.poison.lastTick = time;
                                        nearbyEnemy.statusEffects.poison.stacks = 0;
                                    }
                                });
                            }
                        }
                        effects.poison.duration -= delta;
                        if (effects.poison.duration <= 0) {
                            effects.poison.active = false;
                            effects.poison.stacks = 0;
                        }
                    }

                    // FREEZE - Stop movement (handled in movement code)
                    if (effects.freeze.active) {
                        effects.freeze.duration -= delta;
                        if (effects.freeze.duration <= 0) {
                            effects.freeze.active = false;
                        }
                    }

                    // PARALYZE - Stun (handled in movement code)
                    if (effects.paralyze.active) {
                        // Static Field (Electric upgrade) - paralyzed enemies take damage over time
                        if (this.player.hasStaticField) {
                            if (!effects.paralyze.lastDamageTick) effects.paralyze.lastDamageTick = 0;
                            if (time - effects.paralyze.lastDamageTick >= 500) {
                                const staticDamage = 2;
                                enemy.health -= staticDamage;
                                this.showDamageNumber(enemy.x, enemy.y, staticDamage, 0xffff00);
                                effects.paralyze.lastDamageTick = time;
                            }
                        }

                        effects.paralyze.duration -= delta;
                        if (effects.paralyze.duration <= 0) {
                            effects.paralyze.active = false;
                        }
                    }

                    // SLEEP - Cannot act (handled in movement code)
                    if (effects.sleep.active) {
                        effects.sleep.duration -= delta;
                        if (effects.sleep.duration <= 0) {
                            effects.sleep.active = false;
                        }
                    }

                    // CHARM - Cannot attack player
                    if (effects.charm.active) {
                        effects.charm.duration -= delta;
                        if (effects.charm.duration <= 0) {
                            effects.charm.active = false;
                        }
                    }

                    // CONFUSION - Random movement (handled in movement code)
                    if (effects.confusion.active) {
                        effects.confusion.duration -= delta;
                        if (effects.confusion.duration <= 0) {
                            effects.confusion.active = false;
                        }
                    }

                    // FEAR - Run away from player (handled in movement code)
                    if (effects.fear.active) {
                        effects.fear.duration -= delta;
                        if (effects.fear.duration <= 0) {
                            effects.fear.active = false;
                        }
                    }

                    // SLOW - Reduce speed
                    if (effects.slow.active) {
                        enemy.speed = enemy.originalSpeed * (1 - effects.slow.slowAmount);
                    } else {
                        enemy.speed = enemy.originalSpeed;
                    }

                    // Check if enemy died from status effects
                    if (enemy.health <= 0) {
                        this.killEnemy(enemy);
                    }
                }

                createStatusEffectVisuals(enemy, time) {
                    if (!enemy.statusEffects || !enemy.active) return;

                    const effects = enemy.statusEffects;

                    // BURN - Fire particles
                    if (effects.burn.active) {
                        if (!enemy.lastBurnParticle || time - enemy.lastBurnParticle > 200) {
                            const particle = this.add.graphics();
                            particle.x = enemy.x + Phaser.Math.Between(-8, 8);
                            particle.y = enemy.y + Phaser.Math.Between(-8, 8);
                            const colors = [0xff4500, 0xff6347, 0xffa500];
                            particle.fillStyle(colors[Math.floor(Math.random() * 3)], 0.8);
                            particle.fillCircle(0, 0, Phaser.Math.Between(2, 4));
                            particle.setDepth(15);
                            this.tweens.add({
                                targets: particle,
                                y: particle.y - 20,
                                alpha: 0,
                                duration: 500,
                                onComplete: () => particle.destroy()
                            });
                            enemy.lastBurnParticle = time;
                        }
                    }

                    // FREEZE - Ice overlay
                    if (effects.freeze.active) {
                        if (!enemy.freezeOverlay) {
                            enemy.freezeOverlay = this.add.graphics();
                            enemy.freezeOverlay.fillStyle(0x87ceeb, 0.4);
                            enemy.freezeOverlay.fillCircle(0, 0, 12);
                            enemy.freezeOverlay.lineStyle(2, 0xe0ffff, 0.8);
                            enemy.freezeOverlay.strokeCircle(0, 0, 12);
                            enemy.freezeOverlay.setDepth(14);
                        }
                        enemy.freezeOverlay.x = enemy.x;
                        enemy.freezeOverlay.y = enemy.y;
                    } else if (enemy.freezeOverlay) {
                        enemy.freezeOverlay.destroy();
                        enemy.freezeOverlay = null;
                    }

                    // POISON - Green bubbles
                    if (effects.poison.active) {
                        if (!enemy.lastPoisonBubble || time - enemy.lastPoisonBubble > 300) {
                            const bubble = this.add.graphics();
                            bubble.x = enemy.x + Phaser.Math.Between(-8, 8);
                            bubble.y = enemy.y + Phaser.Math.Between(-8, 8);
                            bubble.lineStyle(2, 0x32cd32, 0.8);
                            bubble.strokeCircle(0, 0, Phaser.Math.Between(3, 5));
                            bubble.setDepth(15);
                            this.tweens.add({
                                targets: bubble,
                                y: bubble.y - 15,
                                alpha: 0,
                                scale: 1.5,
                                duration: 600,
                                onComplete: () => bubble.destroy()
                            });
                            enemy.lastPoisonBubble = time;
                        }
                    }

                    // PARALYZE - Electric sparks
                    if (effects.paralyze.active) {
                        if (!enemy.lastSparkParticle || time - enemy.lastSparkParticle > 100) {
                            const spark = this.add.graphics();
                            spark.x = enemy.x + Phaser.Math.Between(-10, 10);
                            spark.y = enemy.y + Phaser.Math.Between(-10, 10);
                            spark.lineStyle(2, 0xffff00, 1);
                            const endX = Phaser.Math.Between(-8, 8);
                            const endY = Phaser.Math.Between(-8, 8);
                            spark.lineBetween(0, 0, endX, endY);
                            spark.setDepth(15);
                            this.tweens.add({
                                targets: spark,
                                alpha: 0,
                                duration: 200,
                                onComplete: () => spark.destroy()
                            });
                            enemy.lastSparkParticle = time;
                        }
                    }

                    // SLEEP - Zzz symbols
                    if (effects.sleep.active) {
                        if (!enemy.lastSleepZ || time - enemy.lastSleepZ > 800) {
                            const zzz = this.add.text(enemy.x + 10, enemy.y - 15, 'Z', {
                                fontSize: '14px',
                                fill: '#ffffff',
                                fontFamily: 'Courier New'
                            }).setOrigin(0.5).setDepth(15);
                            this.tweens.add({
                                targets: zzz,
                                y: zzz.y - 20,
                                alpha: 0,
                                duration: 800,
                                onComplete: () => zzz.destroy()
                            });
                            enemy.lastSleepZ = time;
                        }
                    }

                    // CHARM - Heart particles
                    if (effects.charm.active) {
                        if (!enemy.lastCharmHeart || time - enemy.lastCharmHeart > 400) {
                            const heart = this.add.text(enemy.x, enemy.y - 12, '‚ô•', {
                                fontSize: '12px',
                                fill: '#ff69b4',
                                fontFamily: 'Arial'
                            }).setOrigin(0.5).setDepth(15);
                            this.tweens.add({
                                targets: heart,
                                y: heart.y - 15,
                                alpha: 0,
                                duration: 600,
                                onComplete: () => heart.destroy()
                            });
                            enemy.lastCharmHeart = time;
                        }
                    }

                    // CONFUSION - Dizzy stars
                    if (effects.confusion.active) {
                        if (!enemy.confusionStars) {
                            enemy.confusionStars = this.add.text(enemy.x, enemy.y - 18, '‚òÖ ‚òÖ ‚òÖ', {
                                fontSize: '10px',
                                fill: '#ffff00',
                                fontFamily: 'Arial'
                            }).setOrigin(0.5).setDepth(15);
                            this.tweens.add({
                                targets: enemy.confusionStars,
                                angle: 360,
                                duration: 1000,
                                repeat: -1
                            });
                        }
                        enemy.confusionStars.x = enemy.x;
                        enemy.confusionStars.y = enemy.y - 18;
                    } else if (enemy.confusionStars) {
                        enemy.confusionStars.destroy();
                        enemy.confusionStars = null;
                    }

                    // BLIND - Dark overlay
                    if (effects.blind.active) {
                        if (!enemy.blindOverlay) {
                            enemy.blindOverlay = this.add.graphics();
                            enemy.blindOverlay.fillStyle(0x000000, 0.5);
                            enemy.blindOverlay.fillCircle(0, 0, 12);
                            enemy.blindOverlay.setDepth(14);
                        }
                        enemy.blindOverlay.x = enemy.x;
                        enemy.blindOverlay.y = enemy.y;
                    } else if (enemy.blindOverlay) {
                        enemy.blindOverlay.destroy();
                        enemy.blindOverlay = null;
                    }

                    // FEAR - Exclamation mark
                    if (effects.fear.active) {
                        if (!enemy.fearMark) {
                            enemy.fearMark = this.add.text(enemy.x, enemy.y - 18, '!', {
                                fontSize: '16px',
                                fill: '#ff0000',
                                fontFamily: 'Arial',
                                fontStyle: 'bold'
                            }).setOrigin(0.5).setDepth(15);
                        }
                        enemy.fearMark.x = enemy.x;
                        enemy.fearMark.y = enemy.y - 18;
                    } else if (enemy.fearMark) {
                        enemy.fearMark.destroy();
                        enemy.fearMark = null;
                    }

                    // SLOW - Blue aura
                    if (effects.slow.active) {
                        if (!enemy.slowAura) {
                            enemy.slowAura = this.add.graphics();
                            enemy.slowAura.lineStyle(2, 0x4169e1, 0.5);
                            enemy.slowAura.strokeCircle(0, 0, 14);
                            enemy.slowAura.setDepth(14);
                        }
                        enemy.slowAura.x = enemy.x;
                        enemy.slowAura.y = enemy.y;
                    } else if (enemy.slowAura) {
                        enemy.slowAura.destroy();
                        enemy.slowAura = null;
                    }
                }

                spawnHazards() {
                    const season = gameState.currentSeason;
                    const hazardCount = 5;

                    for (let i = 0; i < hazardCount; i++) {
                        const hazard = this.add.graphics();
                        hazard.x = Phaser.Math.Between(100, 700);
                        hazard.y = Phaser.Math.Between(100, 500);

                        // Different hazards per season
                        if (season === "spring") {
                            // Thorny bushes
                            hazard.fillStyle(0x2d5016, 1);
                            hazard.fillCircle(0, 0, 20);
                            hazard.fillStyle(0xff0000, 1);
                            for (let j = 0; j < 8; j++) {
                                const angle = (j / 8) * Math.PI * 2;
                                hazard.fillTriangle(
                                    Math.cos(angle) * 15,
                                    Math.sin(angle) * 15,
                                    Math.cos(angle) * 25 - 3,
                                    Math.sin(angle) * 25,
                                    Math.cos(angle) * 25 + 3,
                                    Math.sin(angle) * 25,
                                );
                            }
                            hazard.damageType = "thorns";
                        } else if (season === "summer") {
                            // Fire pits
                            hazard.fillStyle(0xff4500, 0.7);
                            hazard.fillCircle(0, 0, 25);
                            hazard.fillStyle(0xff0000, 1);
                            hazard.fillCircle(0, 0, 15);
                            hazard.fillStyle(0xffd700, 1);
                            hazard.fillCircle(0, -5, 8);
                            hazard.damageType = "fire";

                            // Animate fire
                            this.tweens.add({
                                targets: hazard,
                                alpha: { from: 0.7, to: 1 },
                                scale: { from: 0.95, to: 1.05 },
                                duration: 500,
                                yoyo: true,
                                repeat: -1,
                            });
                        } else if (season === "fall") {
                            // Poison mushrooms
                            hazard.fillStyle(0x8b008b, 1);
                            hazard.fillCircle(0, 5, 18);
                            hazard.fillStyle(0xffffff, 1);
                            hazard.fillCircle(-5, 0, 5);
                            hazard.fillCircle(5, 5, 4);
                            hazard.fillStyle(0x654321, 1);
                            hazard.fillRect(-5, 10, 10, 8);
                            hazard.damageType = "poison";
                        } else if (season === "winter") {
                            // Ice spikes
                            hazard.fillStyle(0x87ceeb, 0.8);
                            hazard.fillTriangle(0, -20, -15, 15, 15, 15);
                            hazard.fillStyle(0xe0ffff, 1);
                            hazard.fillTriangle(0, -18, -8, 10, 8, 10);
                            hazard.damageType = "ice";
                        }

                        this.physics.add.existing(hazard);
                        hazard.body.setCircle(20);
                        hazard.body.immovable = true;
                        hazard.setDepth(5); // Below player but above background
                        hazard.lastDamageTime = 0;

                        this.hazards.push(hazard);
                    }
                }

                repositionHazards() {
                    // Move all hazards to new random positions each wave
                    this.hazards.forEach((hazard) => {
                        if (hazard && hazard.active) {
                            hazard.x = Phaser.Math.Between(100, 700);
                            hazard.y = Phaser.Math.Between(100, 500);
                        }
                    });
                }

                spawnBoss() {
                    const boss = this.add.graphics();
                    boss.x = 400; // Center of screen
                    boss.y = -50; // Spawn from top

                    // Draw boss (large, imposing)
                    this.drawBoss(boss);

                    // Boss stats (very powerful)
                    const bossLevel = Math.floor(this.wave / 5);
                    boss.maxHealth = 500 + bossLevel * 200;
                    boss.health = boss.maxHealth;
                    boss.speed = 35 + bossLevel * 5;
                    boss.damage = (20 + bossLevel * 5) * 2; // Doubled damage
                    boss.xpValue = 200;
                    boss.scoreValue = 500;
                    boss.isBoss = true;
                    boss.enemyType = 99; // Special boss type

                    // Status effect system (same as regular enemies)
                    boss.statusEffects = {
                        burn: { active: false, damage: 3, duration: 0, tickRate: 1000, lastTick: 0 },
                        freeze: { active: false, duration: 0 },
                        poison: { active: false, damage: 2, duration: 0, tickRate: 2000, lastTick: 0, stacks: 0 },
                        paralyze: { active: false, duration: 0 },
                        sleep: { active: false, duration: 0 },
                        charm: { active: false, duration: 0 },
                        confusion: { active: false, duration: 0 },
                        blind: { active: false, accuracyMod: 0.5 },
                        fear: { active: false, duration: 0 },
                        slow: { active: false, slowAmount: 0.4 },
                        knockback: { velocity: { x: 0, y: 0 } }
                    };

                    boss.health = boss.maxHealth;
                    boss.originalSpeed = boss.speed; // Store original speed

                    this.physics.add.existing(boss);
                    boss.body.setSize(40, 40);
                    boss.setDepth(10);
                    this.enemies.add(boss);
                    this.enemiesAlive++;

                    // Boss warning message
                    const warningText = this.add
                        .text(400, 300, "BOSS INCOMING!", {
                            fontSize: "48px",
                            fill: "#ff0000",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                            stroke: "#000000",
                            strokeThickness: 6,
                        })
                        .setOrigin(0.5)
                        .setDepth(1500);

                    // Pulsing animation
                    this.tweens.add({
                        targets: warningText,
                        scale: { from: 1, to: 1.2 },
                        duration: 300,
                        yoyo: true,
                        repeat: 3,
                        onComplete: () => warningText.destroy(),
                    });

                    // Boss entrance shake
                    this.cameras.main.shake(500, 0.005);
                    soundFX.play("enemyDeath"); // Dramatic sound
                }

                drawBoss(graphics) {
                    graphics.clear();
                    const scale = 2; // Bosses are twice as large

                    // Large demon-like boss
                    // Body (dark red, muscular)
                    graphics.fillStyle(0x8b0000, 1);
                    graphics.fillRect(
                        -10 * scale,
                        -5 * scale,
                        20 * scale,
                        20 * scale,
                    );

                    // Chest plates
                    graphics.fillStyle(0xa00000, 1);
                    graphics.fillRect(
                        -8 * scale,
                        -3 * scale,
                        7 * scale,
                        8 * scale,
                    );
                    graphics.fillRect(
                        1 * scale,
                        -3 * scale,
                        7 * scale,
                        8 * scale,
                    );

                    // Head (horned)
                    graphics.fillStyle(0x6b0000, 1);
                    graphics.fillRect(
                        -8 * scale,
                        -12 * scale,
                        16 * scale,
                        10 * scale,
                    );

                    // Horns
                    graphics.fillStyle(0x2a2a2a, 1);
                    graphics.fillTriangle(
                        -8 * scale,
                        -12 * scale,
                        -12 * scale,
                        -18 * scale,
                        -6 * scale,
                        -14 * scale,
                    );
                    graphics.fillTriangle(
                        8 * scale,
                        -12 * scale,
                        12 * scale,
                        -18 * scale,
                        6 * scale,
                        -14 * scale,
                    );

                    // Eyes (glowing yellow)
                    graphics.fillStyle(0xffff00, 1);
                    graphics.fillRect(
                        -6 * scale,
                        -9 * scale,
                        3 * scale,
                        3 * scale,
                    );
                    graphics.fillRect(
                        3 * scale,
                        -9 * scale,
                        3 * scale,
                        3 * scale,
                    );

                    // Fangs
                    graphics.fillStyle(0xffffff, 1);
                    graphics.fillTriangle(
                        -4 * scale,
                        -5 * scale,
                        -2 * scale,
                        -5 * scale,
                        -3 * scale,
                        -2 * scale,
                    );
                    graphics.fillTriangle(
                        2 * scale,
                        -5 * scale,
                        4 * scale,
                        -5 * scale,
                        3 * scale,
                        -2 * scale,
                    );

                    // Massive arms
                    graphics.fillStyle(0x8b0000, 1);
                    graphics.fillRect(
                        -14 * scale,
                        -2 * scale,
                        4 * scale,
                        12 * scale,
                    );
                    graphics.fillRect(
                        10 * scale,
                        -2 * scale,
                        4 * scale,
                        12 * scale,
                    );

                    // Claws
                    graphics.fillStyle(0x2a2a2a, 1);
                    graphics.fillTriangle(
                        -14 * scale,
                        10 * scale,
                        -16 * scale,
                        14 * scale,
                        -12 * scale,
                        12 * scale,
                    );
                    graphics.fillTriangle(
                        14 * scale,
                        10 * scale,
                        16 * scale,
                        14 * scale,
                        12 * scale,
                        12 * scale,
                    );

                    // Legs
                    graphics.fillStyle(0x6b0000, 1);
                    graphics.fillRect(
                        -7 * scale,
                        15 * scale,
                        6 * scale,
                        8 * scale,
                    );
                    graphics.fillRect(
                        1 * scale,
                        15 * scale,
                        6 * scale,
                        8 * scale,
                    );

                    // Aura effect (pulsing)
                    graphics.fillStyle(0xff0000, 0.2);
                    graphics.fillCircle(0, 0, 25 * scale);
                }

                spawnEnemy() {
                    const enemy = this.add.graphics();

                    // Spawn on edges
                    const edge = Phaser.Math.Between(0, 3);
                    switch (edge) {
                        case 0: // Top
                            enemy.x = Phaser.Math.Between(20, 780);
                            enemy.y = -20;
                            break;
                        case 1: // Right
                            enemy.x = 820;
                            enemy.y = Phaser.Math.Between(20, 580);
                            break;
                        case 2: // Bottom
                            enemy.x = Phaser.Math.Between(20, 780);
                            enemy.y = 620;
                            break;
                        case 3: // Left
                            enemy.x = -20;
                            enemy.y = Phaser.Math.Between(20, 580);
                            break;
                    }

                    // Enemy type (more variety in later waves)
                    let enemyType;
                    const rand = Math.random();

                    if (this.wave === 1) {
                        enemyType = 0; // Wave 1: Only slimes
                    } else if (this.wave === 2) {
                        // Wave 2: Mostly slimes but guarantee 1 goblin
                        enemyType = this.enemiesSpawned === 0 ? 1 : 0; // First enemy is goblin, rest are slimes
                    } else if (this.wave < 4) {
                        // Wave 3: Only slimes
                        enemyType = 0;
                    } else if (this.wave < 7) {
                        // Waves 4-6: Slimes and Goblins
                        enemyType = rand < 0.7 ? 0 : 1;
                    } else {
                        // Wave 7+: All enemy types
                        if (rand < 0.4)
                            enemyType = 0; // Slime
                        else if (rand < 0.65)
                            enemyType = 1; // Goblin
                        else if (rand < 0.85)
                            enemyType = 2; // Tank
                        else enemyType = 3; // Bomber
                    }

                    if (enemyType === 0) {
                        // Slime (basic enemy)
                        this.drawSlime(enemy);
                        enemy.maxHealth = 30 + this.wave * 5;
                        enemy.speed = 40 + this.wave * 2;
                        enemy.damage = (5 + this.wave) * 2; // Doubled damage
                        enemy.xpValue = 20;
                        enemy.scoreValue = 10;
                    } else if (enemyType === 1) {
                        // Goblin (stronger, faster)
                        this.drawGoblin(enemy);
                        enemy.maxHealth = 50 + this.wave * 8;
                        enemy.speed = 60 + this.wave * 3;
                        enemy.damage = (8 + this.wave * 2) * 2; // Doubled damage
                        enemy.xpValue = 35;
                        enemy.scoreValue = 25;
                    } else if (enemyType === 2) {
                        // Tank (slow, high HP)
                        this.drawTank(enemy);
                        enemy.maxHealth = 150 + this.wave * 15;
                        enemy.speed = 20 + this.wave;
                        enemy.damage = (12 + this.wave * 2) * 2; // Doubled damage
                        enemy.xpValue = 60;
                        enemy.scoreValue = 50;
                        enemy.isTank = true;
                    } else {
                        // Bomber (teleports, self-destructs)
                        this.drawBomber(enemy);
                        enemy.maxHealth = 20 + this.wave * 3;
                        enemy.speed = 45 + this.wave * 2;
                        enemy.damage = (15 + this.wave * 3) * 2; // Doubled damage
                        enemy.xpValue = 40;
                        enemy.scoreValue = 35;
                        enemy.isBomber = true;
                        enemy.teleportCooldown = 0;
                        enemy.explosionRadius = 80;
                    }

                    enemy.health = enemy.maxHealth;
                    enemy.originalSpeed = enemy.speed; // Store original speed
                    enemy.enemyType = enemyType;

                    // Status effect system
                    enemy.statusEffects = {
                        burn: { active: false, damage: 3, duration: 0, tickRate: 1000, lastTick: 0 },
                        freeze: { active: false, duration: 0 },
                        poison: { active: false, damage: 2, duration: 0, tickRate: 2000, lastTick: 0, stacks: 0 },
                        paralyze: { active: false, duration: 0 },
                        sleep: { active: false, duration: 0 },
                        charm: { active: false, duration: 0 },
                        confusion: { active: false, duration: 0 },
                        blind: { active: false, accuracyMod: 0.5 },
                        fear: { active: false, duration: 0 },
                        slow: { active: false, slowAmount: 0.4 },
                        knockback: { velocity: { x: 0, y: 0 } }
                    };

                    this.physics.add.existing(enemy);
                    enemy.body.setSize(20, 20);
                    enemy.setDepth(10); // Set depth so enemies appear behind UI
                    this.enemies.add(enemy);
                    this.enemiesAlive++;
                }

                drawSlime(graphics) {
                    graphics.clear();

                    // Slime body (green)
                    graphics.fillStyle(0x00ff00, 1);
                    graphics.fillRect(-6, -2, 12, 10);
                    graphics.fillRect(-4, -4, 8, 2);
                    graphics.fillRect(-7, 0, 2, 6);
                    graphics.fillRect(5, 0, 2, 6);

                    // Highlight
                    graphics.fillStyle(0x88ff88, 1);
                    graphics.fillRect(-4, 0, 4, 4);

                    // Eyes
                    graphics.fillStyle(0xffffff, 1);
                    graphics.fillRect(-4, 1, 2, 2);
                    graphics.fillRect(2, 1, 2, 2);

                    graphics.fillStyle(0x000000, 1);
                    graphics.fillRect(-3, 2, 1, 1);
                    graphics.fillRect(3, 2, 1, 1);

                    // Bottom edge
                    graphics.fillStyle(0x00cc00, 1);
                    graphics.fillRect(-6, 6, 12, 2);
                }

                drawGoblin(graphics) {
                    graphics.clear();

                    // Head (green skin)
                    graphics.fillStyle(0x7cb342, 1);
                    graphics.fillRect(-5, -8, 10, 8);

                    // Ears
                    graphics.fillStyle(0x7cb342, 1);
                    graphics.fillRect(-7, -6, 2, 3);
                    graphics.fillRect(5, -6, 2, 3);

                    // Eyes (mean looking)
                    graphics.fillStyle(0xff0000, 1);
                    graphics.fillRect(-4, -5, 2, 2);
                    graphics.fillRect(2, -5, 2, 2);

                    // Body (armor)
                    graphics.fillStyle(0x654321, 1);
                    graphics.fillRect(-5, 0, 10, 8);

                    // Arms
                    graphics.fillStyle(0x7cb342, 1);
                    graphics.fillRect(-7, 1, 2, 5);
                    graphics.fillRect(5, 1, 2, 5);

                    // Weapon (club)
                    graphics.fillStyle(0x8b4513, 1);
                    graphics.fillRect(7, 3, 2, 5);
                    graphics.fillStyle(0x654321, 1);
                    graphics.fillRect(6, 2, 4, 2);

                    // Legs
                    graphics.fillStyle(0x7cb342, 1);
                    graphics.fillRect(-4, 8, 3, 4);
                    graphics.fillRect(1, 8, 3, 4);
                }

                drawTank(graphics) {
                    graphics.clear();

                    // Heavy iron armor body (large)
                    graphics.fillStyle(0x505050, 1);
                    graphics.fillRect(-8, -6, 16, 16);

                    // Armor plates
                    graphics.fillStyle(0x404040, 1);
                    graphics.fillRect(-7, -5, 6, 6);
                    graphics.fillRect(1, -5, 6, 6);
                    graphics.fillRect(-7, 3, 6, 6);
                    graphics.fillRect(1, 3, 6, 6);

                    // Helmet (dark, menacing)
                    graphics.fillStyle(0x303030, 1);
                    graphics.fillRect(-6, -10, 12, 6);

                    // Visor slit (glowing red)
                    graphics.fillStyle(0xff0000, 1);
                    graphics.fillRect(-5, -7, 10, 2);

                    // Large shield
                    graphics.fillStyle(0x606060, 1);
                    graphics.fillRect(-10, -2, 3, 10);
                    graphics.fillStyle(0x808080, 1);
                    graphics.fillRect(-9, -1, 2, 8);

                    // Shoulder spikes
                    graphics.fillStyle(0x707070, 1);
                    graphics.fillTriangle(-8, -6, -10, -10, -6, -8);
                    graphics.fillTriangle(8, -6, 10, -10, 6, -8);

                    // Legs (thick, armored)
                    graphics.fillStyle(0x505050, 1);
                    graphics.fillRect(-6, 10, 5, 6);
                    graphics.fillRect(1, 10, 5, 6);
                }

                drawBomber(graphics) {
                    graphics.clear();

                    // Hooded figure (dark purple/black)
                    graphics.fillStyle(0x2d1b3d, 1);
                    graphics.fillRect(-5, -8, 10, 6);

                    // Hood point
                    graphics.fillStyle(0x2d1b3d, 1);
                    graphics.fillRect(-3, -10, 6, 2);

                    // Glowing eyes (cyan/white)
                    graphics.fillStyle(0x00ffff, 1);
                    graphics.fillRect(-4, -5, 2, 2);
                    graphics.fillRect(2, -5, 2, 2);

                    // Body (robed)
                    graphics.fillStyle(0x4a2d5e, 1);
                    graphics.fillRect(-5, -2, 10, 10);

                    // Bomb strapped to chest (glowing)
                    graphics.fillStyle(0x1a1a1a, 1);
                    graphics.fillCircle(0, 2, 4);

                    // Fuse (sparking)
                    graphics.fillStyle(0xffd700, 1);
                    graphics.fillRect(-1, -2, 2, 3);
                    graphics.fillCircle(0, -3, 2);

                    // Warning symbol on bomb
                    graphics.fillStyle(0xff0000, 1);
                    graphics.fillCircle(0, 2, 2);

                    // Arms (holding bomb)
                    graphics.fillStyle(0x4a2d5e, 1);
                    graphics.fillRect(-7, 0, 2, 6);
                    graphics.fillRect(5, 0, 2, 6);

                    // Tattered robe bottom
                    graphics.fillStyle(0x4a2d5e, 1);
                    graphics.fillRect(-5, 8, 4, 4);
                    graphics.fillRect(1, 8, 4, 4);
                }

                update(time, delta) {
                    if (this.paused) return;

                    // Player movement
                    this.player.body.setVelocity(0);

                    let moveX = 0;
                    let moveY = 0;

                    // Keyboard controls
                    if (this.cursors.left.isDown || this.aKey.isDown)
                        moveX = -1;
                    if (this.cursors.right.isDown || this.dKey.isDown)
                        moveX = 1;
                    if (this.cursors.up.isDown || this.wKey.isDown) moveY = -1;
                    if (this.cursors.down.isDown || this.sKey.isDown) moveY = 1;

                    // Touch controls (override keyboard if active)
                    if (this.touchControls.active) {
                        moveX = this.touchControls.x;
                        moveY = this.touchControls.y;
                    }

                    // Normalize diagonal movement (only if using keyboard)
                    if (
                        !this.touchControls.active &&
                        moveX !== 0 &&
                        moveY !== 0
                    ) {
                        moveX *= 0.707;
                        moveY *= 0.707;
                    }

                    // Check for ice patches (winter season - slippery effect)
                    let isOnIce = false;
                    if (this.icePatches) {
                        this.icePatches.forEach((ice) => {
                            const dist = Phaser.Math.Distance.Between(
                                this.player.x,
                                this.player.y,
                                ice.x,
                                ice.y,
                            );
                            if (dist < 40) {
                                isOnIce = true;
                            }
                        });
                    }

                    // Apply movement with ice slipperiness
                    if (isOnIce) {
                        // Ice makes player slide more (increased speed but less control)
                        this.player.body.setVelocity(
                            moveX * this.player.speed * 1.5, // 50% faster
                            moveY * this.player.speed * 1.5,
                        );
                        // Add slight momentum/slide effect
                        this.player.body.setDrag(50); // Lower drag = more sliding
                    } else {
                        this.player.body.setVelocity(
                            moveX * this.player.speed,
                            moveY * this.player.speed,
                        );
                        this.player.body.setDrag(500); // Normal drag
                    }

                    // Cosmic Dash (Celestial upgrade) - teleport on spacebar
                    if (this.player.hasCosmicDash && Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
                        if (!this.player.lastDashTime) this.player.lastDashTime = 0;
                        const dashCooldown = 5000; // 5 second cooldown
                        if (time - this.player.lastDashTime >= dashCooldown) {
                            // Teleport in the direction of movement, or forward if not moving
                            const dashDistance = 150;
                            let dashX = moveX;
                            let dashY = moveY;
                            if (dashX === 0 && dashY === 0) {
                                dashY = -1; // Default to up if not moving
                            }
                            // Normalize direction
                            const mag = Math.sqrt(dashX * dashX + dashY * dashY);
                            dashX /= mag;
                            dashY /= mag;

                            // Calculate new position
                            const newX = Phaser.Math.Clamp(
                                this.player.x + dashX * dashDistance,
                                30, 770
                            );
                            const newY = Phaser.Math.Clamp(
                                this.player.y + dashY * dashDistance,
                                30, 570
                            );

                            // Teleport effect - flash old position
                            const oldEffect = this.add.graphics();
                            oldEffect.x = this.player.x;
                            oldEffect.y = this.player.y;
                            oldEffect.lineStyle(2, 0x00ffff, 1);
                            oldEffect.strokeCircle(0, 0, 15);
                            oldEffect.setDepth(50);
                            this.tweens.add({
                                targets: oldEffect,
                                alpha: 0,
                                scale: 2,
                                duration: 400,
                                onComplete: () => oldEffect.destroy()
                            });

                            // Teleport player
                            this.player.x = newX;
                            this.player.y = newY;
                            this.player.lastDashTime = time;

                            // Teleport effect - flash new position
                            const newEffect = this.add.graphics();
                            newEffect.x = newX;
                            newEffect.y = newY;
                            newEffect.fillStyle(0x00ffff, 0.5);
                            newEffect.fillCircle(0, 0, 20);
                            newEffect.setDepth(50);
                            this.tweens.add({
                                targets: newEffect,
                                alpha: 0,
                                scale: 2,
                                duration: 400,
                                onComplete: () => newEffect.destroy()
                            });

                            soundFX.play("select"); // Use select sound for dash
                        }
                    }

                    // Update falling leaves (fall season)
                    if (this.fallingLeaves) {
                        this.fallingLeaves.forEach((leaf) => {
                            // Drift downward
                            leaf.y += (leaf.floatSpeed * delta) / 1000;
                            leaf.x += (leaf.driftSpeed * delta) / 1000;

                            // Gentle rotation
                            leaf.rotation += delta / 1000;

                            // Wrap around screen
                            if (leaf.y > 650) {
                                leaf.y = -50;
                                leaf.x = Phaser.Math.Between(0, 800);
                            }
                            if (leaf.x < -50) leaf.x = 850;
                            if (leaf.x > 850) leaf.x = -50;
                        });
                    }

                    // Store movement direction for element-specific attacks
                    if (!this.player.lastMoveX) this.player.lastMoveX = 0;
                    if (!this.player.lastMoveY) this.player.lastMoveY = 0;
                    if (moveX !== 0 || moveY !== 0) {
                        this.player.lastMoveX = moveX;
                        this.player.lastMoveY = moveY;
                    }

                    // Element-specific attacks replace orbs
                    if (this.player.element === 'flame') {
                        this.updateFlamethrowerAttack(moveX, moveY, time);
                    } else if (this.player.element === 'water') {
                        this.updateWaterBulletsAttack(time);
                    } else if (this.player.element === 'electric') {
                        this.updateChainLightningAttack(time);
                    } else if (this.player.element === 'nature') {
                        this.updateSeedPlanting(moveX, moveY, time);
                        this.updateSeedExplosions(time);
                    } else if (this.player.element === 'wind') {
                        this.updateWindBoomerangAttack(time);
                    } else if (this.player.element === 'terra') {
                        this.updateTerrainWalls(moveX, moveY, time);
                    } else {
                        // Default orb attacks for other elements
                        this.updateWizardOrbs();
                    }

                    // Regeneration upgrade (Nature) - heal over time
                    if (this.player.hasRegeneration) {
                        if (!this.player.lastRegenTime) this.player.lastRegenTime = 0;
                        if (time - this.player.lastRegenTime >= 1000) {
                            this.player.health = Math.min(
                                this.player.maxHealth,
                                this.player.health + this.player.regenRate
                            );
                            this.updateHealthBar();
                            this.player.lastRegenTime = time;
                        }
                    }

                    // Update enemies
                    this.enemies.children.entries.forEach((enemy) => {
                        if (!enemy.active) return;

                        // Update boss health bar if boss exists
                        if (enemy.isBoss) {
                            this.updateBossHealthBar(enemy);

                            // Boss laser attack every 3 seconds
                            if (!enemy.lastLaserTime) enemy.lastLaserTime = 0;
                            if (
                                time - enemy.lastLaserTime > 3000 &&
                                !this.paused
                            ) {
                                enemy.lastLaserTime = time;
                                this.bossLaserAttack(enemy);
                            }
                        }

                        // Special behavior for Bomber (teleporting)
                        if (enemy.isBomber) {
                            const dist = Phaser.Math.Distance.Between(
                                enemy.x,
                                enemy.y,
                                this.player.x,
                                this.player.y,
                            );

                            // Teleport closer if far away (cooldown: 3 seconds)
                            if (
                                dist > 200 &&
                                time - enemy.teleportCooldown > 3000 &&
                                !this.paused
                            ) {
                                enemy.teleportCooldown = time;

                                // Teleport effect at old position
                                this.createTeleportEffect(enemy.x, enemy.y);
                                soundFX.play("xpCollect"); // Use existing sound

                                // Teleport near player
                                const angle = Math.random() * Math.PI * 2;
                                enemy.x = this.player.x + Math.cos(angle) * 100;
                                enemy.y = this.player.y + Math.sin(angle) * 100;

                                // Teleport effect at new position
                                this.createTeleportEffect(enemy.x, enemy.y);
                            }

                            // Explode when close to player (and low HP)
                            if (
                                dist < 50 &&
                                enemy.health < enemy.maxHealth * 0.3
                            ) {
                                this.bomberExplode(enemy);
                                return;
                            }
                        }

                        // Special behavior for Tank (laser attack)
                        if (enemy.isTank) {
                            if (!enemy.lastTankLaser) enemy.lastTankLaser = 0;
                            if (
                                time - enemy.lastTankLaser > 4000 &&
                                !this.paused
                            ) {
                                enemy.lastTankLaser = time;
                                this.tankLaserAttack(enemy);
                            }
                        }

                        // Update status effects
                        this.updateStatusEffects(enemy, time, delta);

                        // Create visual effects for active status conditions
                        this.createStatusEffectVisuals(enemy, time);

                        // Check if enemy can move (not frozen, paralyzed, or sleeping)
                        const canMove = enemy.statusEffects &&
                                       !enemy.statusEffects.freeze.active &&
                                       !enemy.statusEffects.paralyze.active &&
                                       !enemy.statusEffects.sleep.active;

                        if (canMove) {
                            // Move towards player, away if feared, or randomly if confused
                            let angle;

                            if (enemy.statusEffects.confusion.active) {
                                // Confused enemies move randomly
                                if (!enemy.randomMove || enemy.randomMove.time <= 0) {
                                    enemy.randomMove = {
                                        x: Math.random() * 2 - 1,
                                        y: Math.random() * 2 - 1,
                                        time: 500,
                                    };
                                }
                                enemy.randomMove.time -= delta;
                                enemy.body.setVelocity(
                                    enemy.randomMove.x * enemy.speed,
                                    enemy.randomMove.y * enemy.speed,
                                );

                                // Event Horizon (Gravity upgrade) - confused enemies damage each other
                                if (this.player.hasEventHorizon) {
                                    if (!enemy.lastConfusionDamageTime) enemy.lastConfusionDamageTime = 0;
                                    if (time - enemy.lastConfusionDamageTime >= 1000) {
                                        this.enemies.children.entries.forEach((otherEnemy) => {
                                            if (otherEnemy === enemy || !otherEnemy.active) return;
                                            const dist = Phaser.Math.Distance.Between(
                                                enemy.x, enemy.y,
                                                otherEnemy.x, otherEnemy.y
                                            );
                                            if (dist < 50) {
                                                const confusionDamage = 3;
                                                otherEnemy.health -= confusionDamage;
                                                this.showDamageNumber(otherEnemy.x, otherEnemy.y, confusionDamage, 0x9933ff);
                                                if (otherEnemy.health <= 0) {
                                                    this.killEnemy(otherEnemy);
                                                }
                                            }
                                        });
                                        enemy.lastConfusionDamageTime = time;
                                    }
                                }
                            } else {
                                angle = Phaser.Math.Angle.Between(
                                    enemy.x,
                                    enemy.y,
                                    this.player.x,
                                    this.player.y,
                                );

                                // Fear makes enemies run away
                                if (enemy.statusEffects.fear.active) {
                                    angle += Math.PI; // Reverse direction
                                }

                                enemy.body.setVelocity(
                                    Math.cos(angle) * enemy.speed,
                                    Math.sin(angle) * enemy.speed,
                                );
                            }
                        } else {
                            // Stop movement if stunned
                            enemy.body.setVelocity(0, 0);
                        }
                    });

                    // Update projectiles (remove if off-screen)
                    this.projectiles.children.entries.forEach((proj) => {
                        if (
                            proj.x < -50 ||
                            proj.x > 850 ||
                            proj.y < -50 ||
                            proj.y > 650
                        ) {
                            proj.destroy();
                        }
                    });

                    // Update damage numbers
                    this.damageNumbers = this.damageNumbers.filter(
                        (dn) => dn.text.active,
                    );

                    // Handle invulnerability
                    if (this.player.invulnerable) {
                        this.player.invulnerableTime -= delta;
                        if (this.player.invulnerableTime <= 0) {
                            this.player.invulnerable = false;
                            this.player.setAlpha(1);
                        } else {
                            // Flicker effect
                            this.player.setAlpha(
                                Math.floor(time / 100) % 2 === 0 ? 0.5 : 1,
                            );
                        }
                    }

                    // Check wave completion
                    const totalEnemiesForWave = this.isBossWave
                        ? 4
                        : this.enemiesThisWave; // Boss + 3 enemies = 4, or just regular enemies
                    const waveEnemiesSpawned = this.isBossWave
                        ? this.enemiesSpawned + 1
                        : this.enemiesSpawned; // +1 for boss if boss wave

                    if (
                        waveEnemiesSpawned >= totalEnemiesForWave &&
                        this.enemiesAlive === 0
                    ) {
                        this.completeWave();
                    }

                    // Check hazard collisions
                    this.hazards.forEach((hazard) => {
                        if (!hazard.active) return;

                        const dist = Phaser.Math.Distance.Between(
                            this.player.x,
                            this.player.y,
                            hazard.x,
                            hazard.y,
                        );

                        if (dist < 35 && time - hazard.lastDamageTime > 1000) {
                            hazard.lastDamageTime = time;
                            const damage = 6; // Doubled from 3 to 6
                            this.player.health -= damage;
                            this.updateHealthBar();
                            this.showDamageNumber(
                                this.player.x,
                                this.player.y,
                                damage,
                            );
                            soundFX.play("playerHit");

                            // Flash hazard
                            hazard.setAlpha(0.5);
                            this.time.delayedCall(100, () => {
                                if (hazard.active) hazard.setAlpha(1);
                            });

                            // Check death
                            if (this.player.health <= 0) {
                                this.gameOver();
                            }
                        }
                    });
                }

                autoAttack() {
                    // Find nearest enemy
                    let nearestEnemy = null;
                    let nearestDist = 999999;

                    this.enemies.children.entries.forEach((enemy) => {
                        if (!enemy.active) return;
                        const dist = Phaser.Math.Distance.Between(
                            this.player.x,
                            this.player.y,
                            enemy.x,
                            enemy.y,
                        );
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    });

                    if (nearestEnemy) {
                        this.shootProjectile(nearestEnemy);
                    }
                }

                shootArrowTowardsMouse() {
                    // Get mouse position in world coordinates (accounting for camera)
                    const pointer = this.input.activePointer;
                    const worldX = pointer.worldX;
                    const worldY = pointer.worldY;

                    const projectile = this.add.graphics();
                    projectile.x = this.player.x;
                    projectile.y = this.player.y;

                    // Draw arrow pointing upward initially
                    projectile.fillStyle(0x8b4513, 1); // Brown shaft
                    projectile.fillRect(-1, -6, 2, 12);

                    projectile.fillStyle(0xc0c0c0, 1); // Silver arrowhead
                    projectile.fillTriangle(0, -8, -3, -4, 3, -4);

                    projectile.fillStyle(0xff0000, 1); // Red fletching
                    projectile.fillTriangle(-2, 6, 0, 4, 2, 6);

                    this.physics.add.existing(projectile);
                    projectile.body.setSize(6, 12);
                    projectile.damage = this.player.damage;

                    // Calculate angle from player to mouse cursor
                    const angle = Phaser.Math.Angle.Between(
                        this.player.x,
                        this.player.y,
                        worldX,
                        worldY,
                    );

                    const speed = 450; // Fast arrow speed for ranged combat
                    projectile.body.setVelocity(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                    );

                    // Rotate arrow to point in direction of travel
                    projectile.setRotation(angle + Math.PI / 2); // +90 degrees because arrow drawn pointing up
                    projectile.setDepth(10);

                    this.projectiles.add(projectile);

                    // Play shoot sound
                    soundFX.play("shoot");

                    // Auto-destroy after 3 seconds or when off-screen
                    this.time.delayedCall(3000, () => {
                        if (projectile.active) projectile.destroy();
                    });
                }

                shootArrowOppositeMovement(moveX, moveY) {
                    const projectile = this.add.graphics();
                    projectile.x = this.player.x;
                    projectile.y = this.player.y;

                    // Draw arrow pointing upward initially
                    projectile.fillStyle(0x8b4513, 1); // Brown shaft
                    projectile.fillRect(-1, -6, 2, 12);

                    projectile.fillStyle(0xc0c0c0, 1); // Silver arrowhead
                    projectile.fillTriangle(0, -8, -3, -4, 3, -4);

                    projectile.fillStyle(0xff0000, 1); // Red fletching
                    projectile.fillTriangle(-2, 6, 0, 4, 2, 6);

                    this.physics.add.existing(projectile);
                    projectile.body.setSize(6, 12);
                    projectile.damage = this.player.damage;

                    // Calculate angle OPPOSITE to movement direction
                    // Invert moveX and moveY to shoot backwards
                    const angle = Math.atan2(-moveY, -moveX);

                    const speed = 450; // Fast arrow speed for ranged combat
                    projectile.body.setVelocity(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                    );

                    // Rotate arrow to point in direction of travel
                    projectile.setRotation(angle + Math.PI / 2); // +90 degrees because arrow drawn pointing up
                    projectile.setDepth(10);

                    this.projectiles.add(projectile);

                    // Play shoot sound
                    soundFX.play("shoot");

                    // Auto-destroy after 3 seconds or when off-screen
                    this.time.delayedCall(3000, () => {
                        if (projectile.active) projectile.destroy();
                    });
                }

                shootProjectile(target) {
                    const projectile = this.add.graphics();
                    projectile.x = this.player.x;
                    projectile.y = this.player.y;

                    // Warrior throws axes
                    projectile.fillStyle(0xc0c0c0, 1);
                    projectile.fillRect(-3, -2, 6, 4);
                    projectile.fillStyle(0x8b4513, 1);
                    projectile.fillRect(-1, 2, 2, 4);

                    this.physics.add.existing(projectile);
                    projectile.body.setSize(8, 8);
                    projectile.damage = this.player.damage;

                    // Shoot towards target
                    const angle = Phaser.Math.Angle.Between(
                        projectile.x,
                        projectile.y,
                        target.x,
                        target.y,
                    );

                    const speed = 300;
                    projectile.body.setVelocity(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                    );

                    // Rotate projectile
                    projectile.setRotation(angle);
                    projectile.setDepth(10); // Behind UI

                    this.projectiles.add(projectile);

                    // Play shoot sound
                    soundFX.play("shoot");

                    // Auto-destroy after 2 seconds
                    this.time.delayedCall(2000, () => {
                        if (projectile.active) projectile.destroy();
                    });
                }

                projectileHitEnemy(projectile, enemy) {
                    if (!projectile.active || !enemy.active) return;

                    // Prevent multiple hits from same projectile (except for piercing bullets)
                    if (projectile.hasHit && !projectile.canPierce) return;

                    // Mark hit if not piercing, or if first hit for piercing
                    if (!projectile.canPierce) {
                        projectile.hasHit = true;
                    }

                    // Deal damage (Tanks take reduced damage)
                    let damage = projectile.damage;
                    if (enemy.isTank) {
                        damage = Math.floor(damage * 0.5); // Tanks take 50% less damage
                    }

                    enemy.health -= damage;

                    // Show damage number
                    this.showDamageNumber(enemy.x, enemy.y, damage);

                    // Play hit sound
                    soundFX.play("hit");

                    // Enhanced hit effect - flash enemy white and create impact particles
                    enemy.setAlpha(0.5);
                    this.time.delayedCall(50, () => {
                        if (enemy.active) enemy.setAlpha(1);
                    });

                    // Impact particles
                    for (let i = 0; i < 5; i++) {
                        const particle = this.add.graphics();
                        particle.x = projectile.x;
                        particle.y = projectile.y;
                        particle.fillStyle(0xffff00, 1);
                        particle.fillCircle(0, 0, 2);
                        particle.setDepth(50);

                        const angle = Math.random() * Math.PI * 2;
                        this.tweens.add({
                            targets: particle,
                            x: projectile.x + Math.cos(angle) * 20,
                            y: projectile.y + Math.sin(angle) * 20,
                            alpha: 0,
                            duration: 200,
                            onComplete: () => particle.destroy(),
                        });
                    }

                    // Destroy projectile
                    projectile.destroy();

                    // Check if enemy died
                    if (enemy.health <= 0) {
                        this.killEnemy(enemy);
                    }
                }

                killEnemy(enemy) {
                    // Spawn XP orb
                    this.spawnXPOrb(enemy.x, enemy.y, enemy.xpValue);

                    // Add score
                    this.score += enemy.scoreValue;
                    this.scoreText.setText(`Score: ${this.score}`);

                    // Death effect (bigger for boss)
                    if (enemy.isBoss) {
                        this.createBossDeathEffect(enemy.x, enemy.y);
                        // Remove boss health bar
                        if (this.bossHealthBarBg) {
                            this.bossHealthBarBg.destroy();
                            this.bossHealthBarBg = null;
                        }
                        if (this.bossHealthBar) {
                            this.bossHealthBar.destroy();
                            this.bossHealthBar = null;
                        }
                        if (this.bossNameText) {
                            this.bossNameText.destroy();
                            this.bossNameText = null;
                        }
                    } else {
                        this.createDeathEffect(enemy.x, enemy.y);
                    }

                    // Play death sound
                    soundFX.play("enemyDeath");

                    // Apply life steal if player has it
                    if (this.player.lifeSteal) {
                        this.player.health = Math.min(
                            this.player.maxHealth,
                            this.player.health + this.player.lifeSteal,
                        );
                        this.updateHealthBar();
                    }

                    // Siphon (Shadow upgrade) - heal 5 HP per feared enemy kill
                    if (this.player.hasSiphon && enemy.statusEffects && enemy.statusEffects.fear.active) {
                        this.player.health = Math.min(
                            this.player.maxHealth,
                            this.player.health + 5
                        );
                        this.updateHealthBar();
                    }

                    // Clean up visual status effect overlays
                    if (enemy.freezeOverlay) enemy.freezeOverlay.destroy();
                    if (enemy.confusionStars) enemy.confusionStars.destroy();
                    if (enemy.blindOverlay) enemy.blindOverlay.destroy();
                    if (enemy.fearMark) enemy.fearMark.destroy();
                    if (enemy.slowAura) enemy.slowAura.destroy();

                    // Remove enemy
                    enemy.destroy();
                    this.enemiesAlive--;
                }

                createBossDeathEffect(x, y) {
                    // Massive explosion for boss
                    for (let i = 0; i < 32; i++) {
                        const particle = this.add.graphics();
                        particle.x = x;
                        particle.y = y;

                        const colors = [0xff0000, 0xff6b00, 0xffed4e, 0xffffff];
                        const color = colors[i % colors.length];

                        const size = Phaser.Math.Between(5, 10);
                        particle.fillStyle(color, 1);
                        particle.fillCircle(0, 0, size);
                        particle.setDepth(50);

                        const angle = (i / 32) * Math.PI * 2;
                        const distance = Phaser.Math.Between(50, 120);

                        this.tweens.add({
                            targets: particle,
                            x: x + Math.cos(angle) * distance,
                            y: y + Math.sin(angle) * distance,
                            alpha: 0,
                            scale: 0,
                            duration: 600 + Math.random() * 300,
                            onComplete: () => particle.destroy(),
                        });
                    }

                    // Multiple explosion rings
                    for (let j = 0; j < 3; j++) {
                        const ring = this.add.graphics();
                        ring.x = x;
                        ring.y = y;
                        ring.setDepth(49);

                        this.tweens.add({
                            targets: ring,
                            duration: 600,
                            delay: j * 150,
                            onUpdate: (tween) => {
                                ring.clear();
                                const progress = tween.progress;
                                const radius = progress * 80;
                                const alpha = 1 - progress;

                                ring.lineStyle(5, 0xff0000, alpha);
                                ring.strokeCircle(0, 0, radius);
                            },
                            onComplete: () => ring.destroy(),
                        });
                    }

                    // Big camera shake
                    this.cameras.main.shake(500, 0.01);

                    // Flash screen red
                    const flash = this.add.graphics();
                    flash.fillStyle(0xff0000, 0.3);
                    flash.fillRect(0, 0, 800, 600);
                    flash.setDepth(1999);
                    this.tweens.add({
                        targets: flash,
                        alpha: 0,
                        duration: 500,
                        onComplete: () => flash.destroy(),
                    });
                }

                bossLaserAttack(boss) {
                    // Laser 1: Aimed at player
                    this.fireBossLaser(boss, this.player.x, this.player.y);

                    // Laser 2: Random direction
                    const randomX = Phaser.Math.Between(100, 700);
                    const randomY = Phaser.Math.Between(100, 500);
                    this.fireBossLaser(boss, randomX, randomY);

                    soundFX.play("shoot");
                }

                tankLaserAttack(tank) {
                    // Slow moving projectile laser
                    const laser = this.add.graphics();
                    laser.x = tank.x;
                    laser.y = tank.y;
                    laser.setDepth(10);

                    // Draw slow laser beam
                    laser.lineStyle(6, 0x00ffff, 1);
                    laser.lineBetween(0, 0, 0, -15);
                    laser.lineStyle(3, 0xffffff, 1);
                    laser.lineBetween(0, 0, 0, -15);

                    // Physics
                    this.physics.add.existing(laser);
                    laser.body.setSize(10, 15);

                    // Aim at player
                    const angle = Phaser.Math.Angle.Between(
                        tank.x,
                        tank.y,
                        this.player.x,
                        this.player.y,
                    );

                    const speed = 120; // Slow moving
                    laser.body.setVelocity(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                    );

                    laser.setRotation(angle + Math.PI / 2);
                    laser.damage = 15;
                    laser.isTankLaser = true;

                    // Add to projectiles for collision
                    this.tankLasers = this.tankLasers || this.add.group();
                    this.tankLasers.add(laser);

                    soundFX.play("shoot");

                    // Auto-destroy after 5 seconds
                    this.time.delayedCall(5000, () => {
                        if (laser.active) laser.destroy();
                    });
                }

                fireBossLaser(boss, targetX, targetY) {
                    const laser = this.add.graphics();
                    laser.x = boss.x;
                    laser.y = boss.y;
                    laser.setDepth(45);

                    // Calculate angle
                    const angle = Phaser.Math.Angle.Between(
                        boss.x,
                        boss.y,
                        targetX,
                        targetY,
                    );

                    // Warning line (red, thin)
                    laser.lineStyle(2, 0xff0000, 0.6);
                    const endX = Math.cos(angle) * 1000;
                    const endY = Math.sin(angle) * 1000;
                    laser.lineBetween(0, 0, endX, endY);

                    // After 0.5 seconds, fire the actual laser
                    this.time.delayedCall(500, () => {
                        if (!laser.active) return;

                        laser.clear();
                        // Actual laser beam (thick, bright)
                        laser.lineStyle(8, 0xff0000, 1);
                        laser.lineBetween(0, 0, endX, endY);

                        // Outer glow
                        laser.lineStyle(12, 0xff6b00, 0.4);
                        laser.lineBetween(0, 0, endX, endY);

                        // Check if player is hit by laser
                        const laserHitbox = new Phaser.Geom.Line(
                            boss.x,
                            boss.y,
                            boss.x + endX,
                            boss.y + endY,
                        );
                        const playerCircle = new Phaser.Geom.Circle(
                            this.player.x,
                            this.player.y,
                            15,
                        );

                        if (
                            Phaser.Geom.Intersects.LineToCircle(
                                laserHitbox,
                                playerCircle,
                            ) &&
                            !this.player.invulnerable
                        ) {
                            const damage = 25;
                            this.player.health -= damage;
                            this.updateHealthBar();
                            this.showDamageNumber(
                                this.player.x,
                                this.player.y,
                                damage,
                            );
                            soundFX.play("playerHit");

                            this.player.invulnerable = true;
                            this.player.invulnerableTime = 1000;

                            // Knockback away from laser
                            const knockbackAngle = angle + Math.PI / 2;
                            this.player.body.setVelocity(
                                Math.cos(knockbackAngle) * 200,
                                Math.sin(knockbackAngle) * 200,
                            );

                            if (this.player.health <= 0) {
                                this.gameOver();
                            }
                        }

                        // Laser disappears after 0.3 seconds
                        this.time.delayedCall(300, () => {
                            if (laser.active) laser.destroy();
                        });
                    });
                }

                spawnXPOrb(x, y, value) {
                    const orb = this.add.graphics();
                    orb.x = x;
                    orb.y = y;
                    orb.xpValue = value;

                    // Draw XP orb
                    orb.fillStyle(0x4169e1, 0.6);
                    orb.fillCircle(0, 0, 8);
                    orb.fillStyle(0x6495ed, 1);
                    orb.fillCircle(0, 0, 5);
                    orb.fillStyle(0xffffff, 1);
                    orb.fillCircle(-2, -2, 2);

                    this.physics.add.existing(orb);
                    orb.body.setCircle(8);
                    orb.setDepth(10); // Behind UI
                    this.xpOrbs.add(orb);

                    // Pulse animation
                    this.tweens.add({
                        targets: orb,
                        scale: 1.2,
                        duration: 500,
                        yoyo: true,
                        repeat: -1,
                    });

                    // Auto-collect after 5 seconds
                    this.time.delayedCall(5000, () => {
                        if (orb.active) {
                            this.tweens.add({
                                targets: orb,
                                x: this.player.x,
                                y: this.player.y,
                                duration: 300,
                                onComplete: () => {
                                    if (orb.active) {
                                        this.collectXP(this.player, orb);
                                    }
                                },
                            });
                        }
                    });
                }

                collectXP(player, orb) {
                    if (!orb.active) return;

                    // Add XP
                    this.player.xp += orb.xpValue;

                    // Check for level up
                    if (this.player.xp >= this.player.xpToNext) {
                        this.levelUp();
                    }

                    this.updateXPBar();

                    // Play collect sound
                    soundFX.play("xpCollect");

                    // Destroy orb
                    orb.destroy();
                }

                levelUp() {
                    this.player.level++;
                    this.player.xp -= this.player.xpToNext;
                    this.player.xpToNext = Math.floor(
                        this.player.xpToNext * 1.5,
                    );

                    this.levelText.setText(`Level: ${this.player.level}`);

                    // Play level up sound
                    soundFX.play("levelUp");

                    // Pause game AND physics
                    this.paused = true;
                    this.physics.pause();

                    // First level up = choose element, after that = upgrades
                    if (this.player.level === 2 && !this.player.element) {
                        this.showElementSelection();
                    } else {
                        this.showUpgradeMenu();
                    }

                    // Level up effect
                    this.createLevelUpEffect();
                }

                showElementSelection() {
                    // Track all UI elements for cleanup
                    const uiElements = [];

                    // Dim background
                    const overlay = this.add.graphics();
                    overlay.fillStyle(0x000000, 0.8);
                    overlay.fillRect(0, 0, 800, 600);
                    overlay.setDepth(100);
                    uiElements.push(overlay);

                    // Title
                    const title = this.add
                        .text(400, 80, "CHOOSE YOUR ELEMENT", {
                            fontSize: "42px",
                            fill: "#ffd700",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                        })
                        .setOrigin(0.5)
                        .setDepth(101);
                    uiElements.push(title);

                    const subtitle = this.add
                        .text(400, 130, "This will define your magical affinity", {
                            fontSize: "18px",
                            fill: "#ffffff",
                            fontFamily: "Courier New",
                        })
                        .setOrigin(0.5)
                        .setDepth(101);
                    uiElements.push(subtitle);

                    // Get 3 random elements
                    const elementKeys = Object.keys(ELEMENTS);
                    const shuffled = Phaser.Utils.Array.Shuffle([...elementKeys]);
                    const selectedElements = shuffled.slice(0, 3);

                    selectedElements.forEach((elementKey, index) => {
                        const element = ELEMENTS[elementKey];
                        const x = 200 + index * 200;
                        const y = 320;

                        // Element panel
                        const panel = this.add.graphics();
                        panel.fillStyle(0x1a1a2a, 0.9);
                        panel.fillRect(x - 80, y - 120, 160, 240);
                        panel.lineStyle(3, element.color, 1);
                        panel.strokeRect(x - 80, y - 120, 160, 240);
                        panel.setDepth(101);
                        uiElements.push(panel);

                        // Icon
                        const icon = this.add
                            .text(x, y - 60, element.icon, {
                                fontSize: "64px",
                            })
                            .setOrigin(0.5)
                            .setDepth(102);
                        uiElements.push(icon);

                        // Name
                        const name = this.add
                            .text(x, y + 10, element.name.toUpperCase(), {
                                fontSize: "20px",
                                fill: element.color,
                                fontFamily: "Courier New",
                                fontStyle: "bold",
                            })
                            .setOrigin(0.5)
                            .setDepth(102);
                        uiElements.push(name);

                        // Description
                        const desc = this.add
                            .text(x, y + 60, element.description, {
                                fontSize: "13px",
                                fill: "#ffffff",
                                fontFamily: "Courier New",
                                align: "center",
                                wordWrap: { width: 140 },
                            })
                            .setOrigin(0.5)
                            .setDepth(102);
                        uiElements.push(desc);

                        // Make interactive
                        const hitArea = new Phaser.Geom.Rectangle(
                            x - 80,
                            y - 120,
                            160,
                            240,
                        );
                        panel.setInteractive(
                            hitArea,
                            Phaser.Geom.Rectangle.Contains,
                        );

                        panel.on("pointerover", () => {
                            panel.clear();
                            panel.fillStyle(0x2a2a3a, 0.95);
                            panel.fillRect(x - 80, y - 120, 160, 240);
                            panel.lineStyle(4, element.color, 1);
                            panel.strokeRect(x - 80, y - 120, 160, 240);
                            this.input.setDefaultCursor("pointer");
                            soundFX.play("hover");
                        });

                        panel.on("pointerout", () => {
                            panel.clear();
                            panel.fillStyle(0x1a1a2a, 0.9);
                            panel.fillRect(x - 80, y - 120, 160, 240);
                            panel.lineStyle(3, element.color, 1);
                            panel.strokeRect(x - 80, y - 120, 160, 240);
                            this.input.setDefaultCursor("default");
                        });

                        panel.on("pointerdown", () => {
                            soundFX.play("select");

                            // Set player element
                            this.player.element = elementKey;

                            // Update character name display
                            this.charNameText.setText(`${element.name.toUpperCase()} WIZARD`);

                            // Change wizard color to match element
                            this.drawWizard(this.player);

                            // Remove orbs for Flame, Water, Electric, and Nature (they use different attack systems)
                            if (elementKey === 'flame' || elementKey === 'water' || elementKey === 'electric' || elementKey === 'nature' || elementKey === 'wind' || elementKey === 'terra') {
                                if (this.wizardOrbs) {
                                    this.wizardOrbs.forEach(orb => {
                                        if (orb && orb.destroy) orb.destroy();
                                    });
                                    this.wizardOrbs = [];
                                }
                            } else {
                                // Change orb colors to match element
                                this.updateOrbColors(element.color);
                            }

                            // Cleanup UI
                            uiElements.forEach((el) => el.destroy());

                            // Unpause
                            this.paused = false;
                            this.physics.resume();

                            // Start next wave if ready
                            if (this.waveReadyToStart) {
                                this.waveReadyToStart = false;
                                this.time.delayedCall(2000, () => this.startWave());
                            }
                        });
                    });
                }

                showUpgradeMenu() {
                    // Track all UI elements for cleanup
                    const uiElements = [];

                    // Dim background
                    const overlay = this.add.graphics();
                    overlay.fillStyle(0x000000, 0.8);
                    overlay.fillRect(0, 0, 800, 600);
                    overlay.setDepth(100);
                    uiElements.push(overlay);

                    // Title
                    const title = this.add
                        .text(400, 100, "LEVEL UP!", {
                            fontSize: "48px",
                            fill: "#ffd700",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                        })
                        .setOrigin(0.5)
                        .setDepth(101);
                    uiElements.push(title);

                    const subtitle = this.add
                        .text(400, 150, "Choose an Upgrade:", {
                            fontSize: "20px",
                            fill: "#ffffff",
                            fontFamily: "Courier New",
                        })
                        .setOrigin(0.5)
                        .setDepth(101);
                    uiElements.push(subtitle);

                    // Generate 3 random upgrades
                    const upgrades = this.generateUpgradeOptions();

                    upgrades.forEach((upgrade, index) => {
                        const x = 200 + index * 200;
                        const y = 300;

                        // Upgrade panel
                        const panel = this.add.graphics();
                        panel.fillStyle(0x1a1a2a, 0.9);
                        panel.fillRect(x - 80, y - 100, 160, 200);
                        panel.lineStyle(3, 0x4a4a5a, 1);
                        panel.strokeRect(x - 80, y - 100, 160, 200);
                        panel.setDepth(101);
                        uiElements.push(panel);

                        // Icon
                        const icon = this.add
                            .text(x, y - 50, upgrade.icon, {
                                fontSize: "48px",
                            })
                            .setOrigin(0.5)
                            .setDepth(102);
                        uiElements.push(icon);

                        // Name
                        const name = this.add
                            .text(x, y + 10, upgrade.name, {
                                fontSize: "16px",
                                fill: "#ffd700",
                                fontFamily: "Courier New",
                                fontStyle: "bold",
                                align: "center",
                                wordWrap: { width: 140 },
                            })
                            .setOrigin(0.5)
                            .setDepth(102);
                        uiElements.push(name);

                        // Description
                        const desc = this.add
                            .text(x, y + 50, upgrade.description, {
                                fontSize: "12px",
                                fill: "#ffffff",
                                fontFamily: "Courier New",
                                align: "center",
                                wordWrap: { width: 140 },
                            })
                            .setOrigin(0.5)
                            .setDepth(102);
                        uiElements.push(desc);

                        // Make interactive
                        const hitArea = new Phaser.Geom.Rectangle(
                            x - 80,
                            y - 100,
                            160,
                            200,
                        );
                        panel.setInteractive(
                            hitArea,
                            Phaser.Geom.Rectangle.Contains,
                        );

                        panel.on("pointerover", () => {
                            panel.clear();
                            panel.fillStyle(0x2a2a3a, 0.9);
                            panel.fillRect(x - 80, y - 100, 160, 200);
                            panel.lineStyle(3, 0x00ff88, 1);
                            panel.strokeRect(x - 80, y - 100, 160, 200);
                            this.input.setDefaultCursor("pointer");
                            soundFX.play("hover");
                        });

                        panel.on("pointerout", () => {
                            panel.clear();
                            panel.fillStyle(0x1a1a2a, 0.9);
                            panel.fillRect(x - 80, y - 100, 160, 200);
                            panel.lineStyle(3, 0x4a4a5a, 1);
                            panel.strokeRect(x - 80, y - 100, 160, 200);
                            this.input.setDefaultCursor("default");
                        });

                        panel.on("pointerdown", () => {
                            // Play select sound
                            soundFX.play("select");

                            // Apply upgrade
                            this.applyUpgrade(upgrade);

                            // Clean up all UI elements
                            uiElements.forEach((element) => {
                                if (element && element.destroy) {
                                    element.destroy();
                                }
                            });

                            // Resume game AND physics
                            this.paused = false;
                            this.physics.resume();

                            // Start next wave if ready
                            if (this.waveReadyToStart) {
                                this.waveReadyToStart = false;
                                this.time.delayedCall(2000, () => this.startWave());
                            }
                        });
                    });
                }

                getElementalUpgrades() {
                    const element = this.player.element;
                    if (!element) return [];

                    const ELEMENTAL_UPGRADES = {
                        flame: [
                            {
                                name: "Inferno Blast",
                                icon: "üí•",
                                description: "Burn damage +2 per tick",
                                apply: () => {
                                    this.player.burnDamageBonus = (this.player.burnDamageBonus || 0) + 2;
                                }
                            },
                            {
                                name: "Wildfire",
                                icon: "üî•",
                                description: "Burn spreads to nearby enemies",
                                apply: () => {
                                    this.player.hasWildfire = true;
                                }
                            },
                            {
                                name: "Molten Core",
                                icon: "üåã",
                                description: "+25% damage to burning enemies",
                                apply: () => {
                                    this.player.moltenCore = (this.player.moltenCore || 1) * 1.25;
                                }
                            },
                            {
                                name: "Firestorm",
                                icon: "‚òÑÔ∏è",
                                description: "Burn lasts +2 seconds",
                                apply: () => {
                                    this.player.burnDurationBonus = (this.player.burnDurationBonus || 0) + 2000;
                                }
                            }
                        ],
                        water: [
                            {
                                name: "Deep Freeze",
                                icon: "‚ùÑÔ∏è",
                                description: "Freeze duration +50%",
                                apply: () => {
                                    this.player.freezeDurationBonus = (this.player.freezeDurationBonus || 1) * 1.5;
                                }
                            },
                            {
                                name: "Glacial Shards",
                                icon: "üíé",
                                description: "Frozen enemies take +30% damage",
                                apply: () => {
                                    this.player.glacialShards = (this.player.glacialShards || 1) * 1.3;
                                }
                            },
                            {
                                name: "Permafrost",
                                icon: "üßä",
                                description: "Freeze chance +5%",
                                apply: () => {
                                    this.player.freezeChanceBonus = (this.player.freezeChanceBonus || 0) + 0.05;
                                }
                            },
                            {
                                name: "Tidal Wave",
                                icon: "üåä",
                                description: "Orbs can freeze 2 enemies at once",
                                apply: () => {
                                    this.player.hasTidalWave = true;
                                }
                            }
                        ],
                        electric: [
                            {
                                name: "Chain Lightning",
                                icon: "‚ö°",
                                description: "Attacks jump to 1 nearby enemy",
                                apply: () => {
                                    this.player.hasChainLightning = true;
                                }
                            },
                            {
                                name: "Overload",
                                icon: "üîå",
                                description: "Paralyze chance +10%",
                                apply: () => {
                                    this.player.paralyzeChanceBonus = (this.player.paralyzeChanceBonus || 0) + 0.10;
                                }
                            },
                            {
                                name: "Static Field",
                                icon: "‚ö°",
                                description: "Paralyzed enemies take damage over time",
                                apply: () => {
                                    this.player.hasStaticField = true;
                                }
                            },
                            {
                                name: "Surge",
                                icon: "üå©Ô∏è",
                                description: "+30% damage vs tank enemies",
                                apply: () => {
                                    this.player.surge = (this.player.surge || 1) * 1.3;
                                }
                            }
                        ],
                        nature: [
                            {
                                name: "Toxic Bloom",
                                icon: "üçÑ",
                                description: "Poison starts at 4 damage",
                                apply: () => {
                                    this.player.poisonDamageBonus = (this.player.poisonDamageBonus || 0) + 2;
                                }
                            },
                            {
                                name: "Regeneration",
                                icon: "üåø",
                                description: "Heal 2 HP per second",
                                apply: () => {
                                    this.player.hasRegeneration = true;
                                    this.player.regenRate = (this.player.regenRate || 0) + 2;
                                }
                            },
                            {
                                name: "Thornmail",
                                icon: "üåπ",
                                description: "Reflect 15% of damage taken",
                                apply: () => {
                                    this.player.thornmail = (this.player.thornmail || 0) + 0.15;
                                }
                            },
                            {
                                name: "Spore Cloud",
                                icon: "‚òÅÔ∏è",
                                description: "Poison spreads to nearby enemies",
                                apply: () => {
                                    this.player.hasSporeCloud = true;
                                }
                            }
                        ],
                        wind: [
                            {
                                name: "Gale Force",
                                icon: "üí®",
                                description: "Knockback distance +50%",
                                apply: () => {
                                    this.player.knockbackBonus = (this.player.knockbackBonus || 1) * 1.5;
                                }
                            },
                            {
                                name: "Zephyr",
                                icon: "üå¨Ô∏è",
                                description: "+20% movement speed",
                                apply: () => {
                                    this.player.speed *= 1.2;
                                }
                            },
                            {
                                name: "Cyclone",
                                icon: "üåÄ",
                                description: "Orb rotation speed +30%",
                                apply: () => {
                                    this.player.orbSpeed *= 1.3;
                                }
                            },
                            {
                                name: "Suffocate",
                                icon: "üò¥",
                                description: "Sleep duration +1 second",
                                apply: () => {
                                    this.player.sleepDurationBonus = (this.player.sleepDurationBonus || 0) + 1000;
                                }
                            }
                        ],
                        terra: [
                            {
                                name: "Earthquake",
                                icon: "üí•",
                                description: "Knockback stuns for 0.5 seconds",
                                apply: () => {
                                    this.player.hasEarthquake = true;
                                }
                            },
                            {
                                name: "Stone Skin",
                                icon: "üóø",
                                description: "+20 max health",
                                apply: () => {
                                    this.player.maxHealth += 20;
                                    this.updateHealthBar();
                                }
                            },
                            {
                                name: "Tremor",
                                icon: "üåç",
                                description: "Knockback affects area around impact",
                                apply: () => {
                                    this.player.hasTremor = true;
                                }
                            },
                            {
                                name: "Mountain's Might",
                                icon: "‚õ∞Ô∏è",
                                description: "+25% knockback power",
                                apply: () => {
                                    this.player.knockbackBonus = (this.player.knockbackBonus || 1) * 1.25;
                                }
                            }
                        ],
                        gravity: [
                            {
                                name: "Gravitational Pull",
                                icon: "üåë",
                                description: "Slow effect 40% ‚Üí 50%",
                                apply: () => {
                                    this.player.slowBonus = (this.player.slowBonus || 0) + 0.10;
                                }
                            },
                            {
                                name: "Singularity",
                                icon: "‚ö´",
                                description: "Confusion duration +1 second",
                                apply: () => {
                                    this.player.confusionDurationBonus = (this.player.confusionDurationBonus || 0) + 1000;
                                }
                            },
                            {
                                name: "Dense Matter",
                                icon: "ü™®",
                                description: "Slow affects larger area",
                                apply: () => {
                                    this.player.hasDenseMatter = true;
                                }
                            },
                            {
                                name: "Event Horizon",
                                icon: "üåå",
                                description: "Confused enemies damage each other",
                                apply: () => {
                                    this.player.hasEventHorizon = true;
                                }
                            }
                        ],
                        celestial: [
                            {
                                name: "Astral Chains",
                                icon: "‚≠ê",
                                description: "Charm duration +1 second",
                                apply: () => {
                                    this.player.charmDurationBonus = (this.player.charmDurationBonus || 0) + 1000;
                                }
                            },
                            {
                                name: "Starfall",
                                icon: "‚ú®",
                                description: "Charm chance +3%",
                                apply: () => {
                                    this.player.charmChanceBonus = (this.player.charmChanceBonus || 0) + 0.03;
                                }
                            },
                            {
                                name: "Cosmic Dash",
                                icon: "üå†",
                                description: "Teleport short distance (Spacebar, 5s cooldown)",
                                apply: () => {
                                    this.player.hasCosmicDash = true;
                                }
                            },
                            {
                                name: "Void Step",
                                icon: "üåå",
                                description: "10% chance to dodge attacks",
                                apply: () => {
                                    this.player.dodgeChance = (this.player.dodgeChance || 0) + 0.10;
                                }
                            }
                        ],
                        radiant: [
                            {
                                name: "Divine Blessing",
                                icon: "‚úùÔ∏è",
                                description: "+15% damage",
                                apply: () => {
                                    this.player.damage = Math.floor(this.player.damage * 1.15);
                                }
                            },
                            {
                                name: "Brilliant Flash",
                                icon: "üí°",
                                description: "Blind chance +10%",
                                apply: () => {
                                    this.player.blindChanceBonus = (this.player.blindChanceBonus || 0) + 0.10;
                                }
                            },
                            {
                                name: "Beacon of Hope",
                                icon: "üïØÔ∏è",
                                description: "Heal 3 HP per kill",
                                apply: () => {
                                    this.player.lifeSteal = (this.player.lifeSteal || 0) + 3;
                                }
                            },
                            {
                                name: "Radiant Shield",
                                icon: "üõ°Ô∏è",
                                description: "Reduce damage taken by 10%",
                                apply: () => {
                                    this.player.damageReduction = (this.player.damageReduction || 0) + 0.10;
                                }
                            }
                        ],
                        shadow: [
                            {
                                name: "Nightmare",
                                icon: "üò±",
                                description: "Fear duration +1 second",
                                apply: () => {
                                    this.player.fearDurationBonus = (this.player.fearDurationBonus || 0) + 1000;
                                }
                            },
                            {
                                name: "Dark Embrace",
                                icon: "üåë",
                                description: "Fear chance +5%",
                                apply: () => {
                                    this.player.fearChanceBonus = (this.player.fearChanceBonus || 0) + 0.05;
                                }
                            },
                            {
                                name: "Siphon",
                                icon: "üíÄ",
                                description: "Heal 5 HP per feared enemy kill",
                                apply: () => {
                                    this.player.hasSiphon = true;
                                }
                            },
                            {
                                name: "Umbral Shroud",
                                icon: "üå´Ô∏è",
                                description: "Enemies have -15% accuracy",
                                apply: () => {
                                    this.player.hasUmbralShroud = true;
                                }
                            }
                        ]
                    };

                    return ELEMENTAL_UPGRADES[element] || [];
                }

                generateUpgradeOptions() {
                    // Universal upgrade (always available)
                    const universalUpgrades = [
                        {
                            name: "Health Boost",
                            icon: "‚ù§Ô∏è",
                            description: "+20 Max HP\nRestore 30 HP",
                            apply: () => {
                                this.player.maxHealth += 20;
                                this.player.health = Math.min(
                                    this.player.maxHealth,
                                    this.player.health + 30,
                                );
                                this.updateHealthBar();
                            },
                        }
                    ];

                    // Get element-specific upgrades
                    const elementalUpgrades = this.getElementalUpgrades();

                    // Combine universal + elemental upgrades
                    const allUpgrades = [...universalUpgrades, ...elementalUpgrades];

                    // Filter out upgrades already taken (optional - could allow stacking)
                    const availableUpgrades = allUpgrades.filter(upgrade => {
                        // Allow upgrades to be taken multiple times for now
                        return true;
                    });

                    // Return 3 random upgrades
                    return Phaser.Utils.Array.Shuffle(availableUpgrades).slice(0, 3);
                }

                applyUpgrade(upgrade) {
                    upgrade.apply();
                }

                createLevelUpEffect() {
                    // Ring effect
                    const effect = this.add.graphics();
                    effect.x = this.player.x;
                    effect.y = this.player.y;
                    effect.setDepth(50);

                    this.tweens.add({
                        targets: effect,
                        duration: 800,
                        onUpdate: (tween) => {
                            effect.clear();
                            const progress = tween.progress;
                            const radius = 10 + progress * 50;
                            const alpha = 1 - progress;

                            effect.lineStyle(4, 0xffd700, alpha);
                            effect.strokeCircle(0, 0, radius);
                        },
                        onComplete: () => effect.destroy(),
                    });

                    // Particles
                    for (let i = 0; i < 12; i++) {
                        const particle = this.add.graphics();
                        particle.x = this.player.x;
                        particle.y = this.player.y;
                        particle.fillStyle(0xffd700, 1);
                        particle.fillCircle(0, 0, 3);
                        particle.setDepth(50);

                        const angle = (i / 12) * Math.PI * 2;
                        this.tweens.add({
                            targets: particle,
                            x: this.player.x + Math.cos(angle) * 60,
                            y: this.player.y + Math.sin(angle) * 60,
                            alpha: 0,
                            duration: 600,
                            onComplete: () => particle.destroy(),
                        });
                    }
                }

                createDeathEffect(x, y) {
                    // Enhanced explosion particles with more variety
                    for (let i = 0; i < 16; i++) {
                        const particle = this.add.graphics();
                        particle.x = x;
                        particle.y = y;

                        const colors = [0xff6b6b, 0xffa502, 0xffed4e, 0xff4500];
                        const color = colors[i % colors.length];

                        // Vary particle sizes
                        const size = Phaser.Math.Between(3, 6);
                        particle.fillStyle(color, 1);
                        particle.fillCircle(0, 0, size);
                        particle.setDepth(50);

                        const angle = (i / 16) * Math.PI * 2;
                        const distance = Phaser.Math.Between(30, 60);

                        this.tweens.add({
                            targets: particle,
                            x: x + Math.cos(angle) * distance,
                            y: y + Math.sin(angle) * distance,
                            alpha: 0,
                            scale: 0,
                            duration: 400 + Math.random() * 200,
                            onComplete: () => particle.destroy(),
                        });
                    }

                    // Add explosion ring
                    const ring = this.add.graphics();
                    ring.x = x;
                    ring.y = y;
                    ring.setDepth(49);

                    this.tweens.add({
                        targets: ring,
                        duration: 300,
                        onUpdate: (tween) => {
                            ring.clear();
                            const progress = tween.progress;
                            const radius = progress * 40;
                            const alpha = 1 - progress;

                            ring.lineStyle(3, 0xff6b00, alpha);
                            ring.strokeCircle(0, 0, radius);
                        },
                        onComplete: () => ring.destroy(),
                    });

                    // Small camera shake on death
                    this.cameras.main.shake(100, 0.002);
                }

                bomberExplode(enemy) {
                    // Create large explosion
                    const explosionRadius = enemy.explosionRadius;

                    // Explosion visual
                    const explosion = this.add.graphics();
                    explosion.x = enemy.x;
                    explosion.y = enemy.y;
                    explosion.setDepth(50);

                    // Animate explosion growing
                    this.tweens.add({
                        targets: explosion,
                        duration: 400,
                        onUpdate: (tween) => {
                            explosion.clear();
                            const progress = tween.progress;
                            const radius = explosionRadius * progress;
                            const alpha = 1 - progress;

                            // Outer blast
                            explosion.fillStyle(0xff6b00, alpha * 0.8);
                            explosion.fillCircle(0, 0, radius);

                            // Inner blast
                            explosion.fillStyle(0xff0000, alpha);
                            explosion.fillCircle(0, 0, radius * 0.7);

                            // Core
                            explosion.fillStyle(0xffff00, alpha);
                            explosion.fillCircle(0, 0, radius * 0.4);
                        },
                        onComplete: () => explosion.destroy(),
                    });

                    // Camera shake
                    this.cameras.main.shake(300, 0.01);

                    // Play explosion sound
                    soundFX.play("enemyDeath");

                    // Damage player if in range
                    const distToPlayer = Phaser.Math.Distance.Between(
                        enemy.x,
                        enemy.y,
                        this.player.x,
                        this.player.y,
                    );

                    if (
                        distToPlayer < explosionRadius &&
                        !this.player.invulnerable
                    ) {
                        const damage = enemy.damage * 2; // Double damage from explosion
                        this.player.health -= damage;
                        this.updateHealthBar();
                        this.showDamageNumber(
                            this.player.x,
                            this.player.y,
                            damage,
                        );
                        soundFX.play("playerHit");

                        // Invulnerability
                        this.player.invulnerable = true;
                        this.player.invulnerableTime = 1000;

                        // Knockback
                        const angle = Math.atan2(
                            this.player.y - enemy.y,
                            this.player.x - enemy.x,
                        );
                        this.player.body.setVelocity(
                            Math.cos(angle) * 300,
                            Math.sin(angle) * 300,
                        );

                        if (this.player.health <= 0) {
                            this.gameOver();
                        }
                    }

                    // Damage other enemies in range
                    this.enemies.children.entries.forEach((otherEnemy) => {
                        if (!otherEnemy.active || otherEnemy === enemy) return;

                        const dist = Phaser.Math.Distance.Between(
                            enemy.x,
                            enemy.y,
                            otherEnemy.x,
                            otherEnemy.y,
                        );

                        if (dist < explosionRadius) {
                            const damage = enemy.damage;
                            otherEnemy.health -= damage;
                            this.showDamageNumber(
                                otherEnemy.x,
                                otherEnemy.y,
                                damage,
                            );

                            if (otherEnemy.health <= 0) {
                                this.killEnemy(otherEnemy);
                            }
                        }
                    });

                    // Give XP and score for suicide bombing
                    this.spawnXPOrb(enemy.x, enemy.y, enemy.xpValue);
                    this.score += enemy.scoreValue;
                    this.scoreText.setText(`Score: ${this.score}`);

                    // Remove bomber
                    enemy.destroy();
                    this.enemiesAlive--;
                }

                createTeleportEffect(x, y) {
                    // Purple/cyan teleport particles
                    for (let i = 0; i < 12; i++) {
                        const particle = this.add.graphics();
                        particle.x = x;
                        particle.y = y + (i - 6) * 5;

                        particle.fillStyle(0x00ffff, 1);
                        particle.fillCircle(0, 0, 3);
                        particle.setDepth(50);

                        this.tweens.add({
                            targets: particle,
                            x: x + (Math.random() - 0.5) * 40,
                            y: particle.y + (Math.random() - 0.5) * 40,
                            alpha: 0,
                            scale: 0,
                            duration: 300,
                            onComplete: () => particle.destroy(),
                        });
                    }
                }

                showDamageNumber(x, y, damage) {
                    const text = this.add
                        .text(x, y - 20, damage.toString(), {
                            fontSize: "20px",
                            fill: "#ff0000",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                            stroke: "#000000",
                            strokeThickness: 3,
                        })
                        .setOrigin(0.5);

                    this.damageNumbers.push({ text });

                    this.tweens.add({
                        targets: text,
                        y: y - 50,
                        alpha: 0,
                        duration: 800,
                        onComplete: () => text.destroy(),
                    });
                }

                playerHitEnemy(player, enemy) {
                    if (!enemy.active || this.player.invulnerable) return;

                    // Void Step (Celestial) - chance to dodge attacks
                    if (this.player.dodgeChance && Math.random() < this.player.dodgeChance) {
                        // Dodged! Show "DODGE" text
                        const dodgeText = this.add.text(this.player.x, this.player.y - 30, "DODGE", {
                            fontSize: "16px",
                            fill: "#00ffff",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                        }).setOrigin(0.5).setDepth(100);

                        this.tweens.add({
                            targets: dodgeText,
                            y: this.player.y - 60,
                            alpha: 0,
                            duration: 800,
                            onComplete: () => dodgeText.destroy(),
                        });
                        return; // No damage taken
                    }

                    // Umbral Shroud (Shadow) - enemies have reduced accuracy
                    if (this.player.hasUmbralShroud && Math.random() < 0.15) {
                        // Enemy missed! Show "MISS" text
                        const missText = this.add.text(this.player.x, this.player.y - 30, "MISS", {
                            fontSize: "16px",
                            fill: "#9966cc",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                        }).setOrigin(0.5).setDepth(100);

                        this.tweens.add({
                            targets: missText,
                            y: this.player.y - 60,
                            alpha: 0,
                            duration: 800,
                            onComplete: () => missText.destroy(),
                        });
                        return; // No damage taken
                    }

                    // Calculate damage (reduced by defense)
                    let damage = Math.max(1, enemy.damage - this.player.defense);

                    // Radiant Shield (Radiant) - reduce damage taken
                    if (this.player.damageReduction) {
                        damage = Math.floor(damage * (1 - this.player.damageReduction));
                        damage = Math.max(1, damage); // At least 1 damage
                    }

                    this.player.health -= damage;
                    this.updateHealthBar();

                    // Thornmail (Nature) - reflect damage back to attacker
                    if (this.player.thornmail) {
                        const reflectDamage = Math.floor(damage * this.player.thornmail);
                        enemy.health -= reflectDamage;
                        this.showDamageNumber(enemy.x, enemy.y, reflectDamage, 0x32cd32); // Green damage for reflect

                        if (enemy.health <= 0) {
                            this.killEnemy(enemy);
                        }
                    }

                    // Show damage on player
                    this.showDamageNumber(this.player.x, this.player.y, damage);

                    // Play player hit sound
                    soundFX.play("playerHit");

                    // Invulnerability frames
                    this.player.invulnerable = true;
                    this.player.invulnerableTime = 1000;

                    // Knockback
                    const angle = Phaser.Math.Angle.Between(
                        enemy.x,
                        enemy.y,
                        this.player.x,
                        this.player.y,
                    );
                    this.player.body.setVelocity(
                        Math.cos(angle) * 200,
                        Math.sin(angle) * 200,
                    );

                    // Camera shake
                    this.cameras.main.shake(100, 0.005);

                    // Check death
                    if (this.player.health <= 0) {
                        this.gameOver();
                    }
                }

                completeWave() {
                    this.wave++;
                    this.enemiesThisWave = Math.floor(
                        this.enemiesThisWave * 1.3,
                    );

                    // Give XP to guarantee 1 level-up per wave
                    const xpNeeded = this.player.xpToNext - this.player.xp;
                    this.player.xp += xpNeeded;

                    // Set flag to start wave after level-up selection completes
                    this.waveReadyToStart = true;

                    // Trigger level-up
                    if (this.player.xp >= this.player.xpToNext) {
                        this.levelUp();
                    }

                    // Safety fallback: if wave doesn't start after 10 seconds, force it
                    this.time.delayedCall(10000, () => {
                        if (this.waveReadyToStart && this.wave > 1) {
                            console.log(`Safety fallback: Force starting Wave ${this.wave}`);
                            this.waveReadyToStart = false;
                            this.startWave();
                        }
                    });

                    // Show wave complete message
                    const message = this.add
                        .text(400, 250, `Wave ${this.wave - 1} Complete!`, {
                            fontSize: "36px",
                            fill: "#00ff00",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                            stroke: "#000000",
                            strokeThickness: 4,
                        })
                        .setOrigin(0.5);

                    this.tweens.add({
                        targets: message,
                        alpha: 0,
                        y: 200,
                        duration: 2000,
                        onComplete: () => message.destroy(),
                    });

                    // NOTE: startWave() will be called after player selects upgrade/element
                }

                gameOver() {
                    this.paused = true;

                    // Stop background music
                    if (this.bgMusic) {
                        this.bgMusic.stop();
                    }

                    // Cleanup wizard orbs if needed
                    if (this.wizardOrbs) {
                        this.wizardOrbs.forEach((orb) => {
                            if (orb && orb.destroy) orb.destroy();
                        });
                        this.wizardOrbs = [];
                    }

                    // Update high score
                    const finalScore = this.score + this.survivalTime * 10;
                    if (finalScore > gameState.highScore) {
                        gameState.highScore = finalScore;
                    }

                    // Save game stats
                    gameState.currentLevel = this.player.level;
                    gameState.totalXP = this.player.xp;
                    gameState.enemiesKilled =
                        this.wave * this.enemiesThisWave - this.enemiesAlive;
                    gameState.survivalTime = this.survivalTime;

                    this.cameras.main.fade(1000, 0, 0, 0);
                    this.time.delayedCall(1000, () => {
                        this.scene.start("GameOverScene", {
                            score: finalScore,
                        });
                    });
                }
            }

            // Game Over Scene
            class GameOverScene extends Phaser.Scene {
                constructor() {
                    super({ key: "GameOverScene" });
                }

                init(data) {
                    this.finalScore = data.score;
                }

                create() {
                    // Background
                    const bg = this.add.graphics();
                    bg.fillStyle(0x1a1a2e, 1);
                    bg.fillRect(0, 0, 800, 600);

                    // Title
                    this.add
                        .text(400, 100, "GAME OVER", {
                            fontSize: "48px",
                            fill: "#ff6b6b",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                        })
                        .setOrigin(0.5);

                    // Stats panel
                    const panelGraphics = this.add.graphics();
                    panelGraphics.fillStyle(0x0f0f1e, 0.9);
                    panelGraphics.fillRect(200, 180, 400, 280);
                    panelGraphics.lineStyle(3, 0x4a4a5a, 1);
                    panelGraphics.strokeRect(200, 180, 400, 280);

                    // Stats (always wizard now)
                    const charName = "Wizard";
                    const stats = [
                        `Character: ${charName}`,
                        `Final Level: ${gameState.currentLevel}`,
                        `Survival Time: ${Math.floor(gameState.survivalTime / 60)}:${(gameState.survivalTime % 60).toString().padStart(2, "0")}`,
                        `Enemies Defeated: ${gameState.enemiesKilled}`,
                        `Final Score: ${this.finalScore}`,
                        `High Score: ${gameState.highScore}`,
                    ];

                    stats.forEach((stat, index) => {
                        const color =
                            index === stats.length - 1 ? "#ffd700" : "#ffffff";
                        this.add
                            .text(400, 220 + index * 40, stat, {
                                fontSize: "20px",
                                fill: color,
                                fontFamily: "Courier New",
                                fontStyle:
                                    index === stats.length - 1
                                        ? "bold"
                                        : "normal",
                            })
                            .setOrigin(0.5);
                    });

                    // Play Again Button
                    const playButton = this.add
                        .text(400, 520, "PLAY AGAIN", {
                            fontSize: "24px",
                            fill: "#00ff88",
                            fontFamily: "Courier New",
                            fontStyle: "bold",
                            backgroundColor: "#1a1a2a",
                            padding: { x: 20, y: 10 },
                        })
                        .setOrigin(0.5)
                        .setInteractive();

                    playButton.on("pointerover", () => {
                        playButton.setFill("#ffffff");
                        this.input.setDefaultCursor("pointer");
                        soundFX.play("hover");
                    });

                    playButton.on("pointerout", () => {
                        playButton.setFill("#00ff88");
                        this.input.setDefaultCursor("default");
                    });

                    playButton.on("pointerdown", () => {
                        soundFX.play("select");
                        this.scene.start("CharacterSelectScene");
                    });

                    // Fade in
                    this.cameras.main.fadeIn(500);
                }
            }

            // Game Configuration - After all classes are defined
            const config = {
                type: Phaser.AUTO,
                width: 800,
                height: 600,
                parent: "game-container",
                backgroundColor: "#2d2d44",
                physics: {
                    default: "arcade",
                    arcade: {
                        gravity: { y: 0 },
                        debug: false,
                    },
                },
                scale: {
                    mode: Phaser.Scale.FIT,
                    autoCenter: Phaser.Scale.CENTER_BOTH,
                    fullscreenTarget: "game-container",
                },
                scene: [CharacterSelectScene, GameScene, GameOverScene],
            };

            const game = new Phaser.Game(config);
        </script>
    </body>
</html>
